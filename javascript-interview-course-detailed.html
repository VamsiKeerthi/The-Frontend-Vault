<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JavaScript ‚Äî Interview Ready (Detailed)</title>
<link href="https://fonts.googleapis.com/css2?family=Syne:wght@400;700;800&family=JetBrains+Mono:ital,wght@0,400;0,500;1,400&family=Crimson+Pro:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
<style>
:root{--bg:#0c0e14;--surface:#13151f;--surface2:#1a1d2e;--surface3:#21253a;--accent:#f7c948;--accent2:#e85d4a;--accent3:#3ecf8e;--accent4:#60a5fa;--text:#e2e4f0;--muted:#6b7090;--border:rgba(255,255,255,0.06);--border-hover:rgba(247,201,72,0.25);--code-bg:#090b10;--sidebar-w:290px;}
*{margin:0;padding:0;box-sizing:border-box;}
body{background:var(--bg);color:var(--text);font-family:'Crimson Pro',Georgia,serif;min-height:100vh;overflow-x:hidden;}
::-webkit-scrollbar{width:3px;height:3px;}::-webkit-scrollbar-track{background:transparent;}::-webkit-scrollbar-thumb{background:rgba(247,201,72,0.25);border-radius:2px;}
.app{display:flex;min-height:100vh;}
.sidebar{width:var(--sidebar-w);min-width:var(--sidebar-w);background:var(--surface);border-right:1px solid var(--border);height:100vh;position:sticky;top:0;overflow-y:auto;overflow-x:hidden;scrollbar-width:thin;display:flex;flex-direction:column;}
.sidebar-brand{padding:28px 22px 18px;border-bottom:1px solid var(--border);flex-shrink:0;}
.brand-js{font-family:'Syne',sans-serif;font-size:2.4rem;font-weight:800;color:var(--accent);line-height:1;letter-spacing:-1px;}
.brand-sub{font-family:'JetBrains Mono',monospace;font-size:0.58rem;letter-spacing:3px;color:var(--muted);text-transform:uppercase;margin-top:5px;}
.prog-wrap{padding:14px 22px;border-bottom:1px solid var(--border);flex-shrink:0;}
.prog-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:7px;}
.prog-label{font-family:'JetBrains Mono',monospace;font-size:0.58rem;letter-spacing:2px;color:var(--muted);text-transform:uppercase;}
.prog-pct{font-family:'Syne',sans-serif;font-size:0.85rem;font-weight:700;color:var(--accent);}
.prog-track{height:2px;background:var(--border);border-radius:2px;overflow:hidden;}
.prog-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));width:0%;transition:width 0.5s ease;border-radius:2px;}
.nav-group{border-bottom:1px solid var(--border);padding:8px 0;}
.nav-group-label{font-family:'JetBrains Mono',monospace;font-size:0.56rem;letter-spacing:3px;text-transform:uppercase;color:var(--muted);padding:8px 22px 4px;display:flex;align-items:center;gap:8px;}
.nav-group-label span{width:16px;height:16px;background:var(--surface3);border-radius:3px;display:inline-flex;align-items:center;justify-content:center;font-size:0.5rem;color:var(--accent);font-weight:700;}
.nav-item{display:flex;align-items:center;gap:10px;padding:7px 22px;cursor:pointer;font-family:'JetBrains Mono',monospace;font-size:0.68rem;color:var(--muted);border-left:2px solid transparent;transition:all 0.18s;line-height:1.3;user-select:none;}
.nav-item:hover{color:var(--text);background:rgba(255,255,255,0.02);}
.nav-item.active{color:var(--accent);border-left-color:var(--accent);background:rgba(247,201,72,0.05);}
.nav-item.visited:not(.active){color:rgba(62,207,142,0.7);}
.nav-item .ni-dot{width:5px;height:5px;border-radius:50%;background:currentColor;flex-shrink:0;opacity:0.7;}
.nav-item.visited:not(.active) .ni-dot{background:var(--accent3);}
.main{flex:1;overflow-y:auto;overflow-x:hidden;scrollbar-width:thin;}
.hero{padding:70px 72px 54px;background:linear-gradient(135deg,#0c0e14 0%,#111420 60%,#0c1014 100%);border-bottom:1px solid var(--border);position:relative;overflow:hidden;}
.hero::before{content:'';position:absolute;top:-120px;right:-80px;width:500px;height:500px;background:radial-gradient(circle,rgba(247,201,72,0.07) 0%,transparent 65%);pointer-events:none;}
.hero::after{content:'JS';position:absolute;bottom:-40px;right:40px;font-family:'Syne',sans-serif;font-size:16rem;font-weight:800;color:rgba(247,201,72,0.03);line-height:1;pointer-events:none;user-select:none;letter-spacing:-10px;}
.hero-eyebrow{font-family:'JetBrains Mono',monospace;font-size:0.68rem;letter-spacing:4px;color:var(--accent);text-transform:uppercase;margin-bottom:18px;}
.hero-title{font-family:'Syne',sans-serif;font-size:4rem;font-weight:800;line-height:1.05;color:#fff;letter-spacing:-2px;margin-bottom:20px;}
.hero-title em{font-style:normal;color:var(--accent);}
.hero-desc{font-size:1.05rem;color:var(--muted);max-width:560px;line-height:1.8;font-style:italic;}
.hero-stats{display:flex;gap:40px;margin-top:40px;}
.stat-num{font-family:'Syne',sans-serif;font-size:2.2rem;font-weight:800;color:var(--accent);line-height:1;}
.stat-lbl{font-family:'JetBrains Mono',monospace;font-size:0.58rem;letter-spacing:2px;color:var(--muted);text-transform:uppercase;margin-top:4px;}
.content{padding:0 72px 80px;}
.section{padding:56px 0 40px;border-bottom:1px solid var(--border);display:none;animation:fadeIn 0.4s ease;}
.section.active{display:block;}
@keyframes fadeIn{from{opacity:0;transform:translateY(14px);}to{opacity:1;transform:translateY(0);}}
.section-head{display:flex;align-items:flex-start;gap:18px;margin-bottom:36px;}
.sec-num{font-family:'Syne',sans-serif;font-size:4.5rem;font-weight:800;color:rgba(247,201,72,0.1);line-height:1;flex-shrink:0;letter-spacing:-3px;min-width:90px;text-align:right;}
.sec-title{font-family:'Syne',sans-serif;font-size:2rem;font-weight:800;color:#fff;letter-spacing:-0.5px;}
.sec-sub{font-family:'JetBrains Mono',monospace;font-size:0.65rem;color:var(--muted);letter-spacing:2px;margin-top:6px;}
.topic-row{display:flex;flex-wrap:wrap;gap:7px;margin-bottom:28px;}
.topic{font-family:'JetBrains Mono',monospace;font-size:0.6rem;letter-spacing:1px;padding:3px 9px;border-radius:2px;background:rgba(247,201,72,0.08);color:var(--accent);border:1px solid rgba(247,201,72,0.15);}
.topic.g{background:rgba(62,207,142,0.08);color:var(--accent3);border-color:rgba(62,207,142,0.15);}
.topic.r{background:rgba(232,93,74,0.08);color:var(--accent2);border-color:rgba(232,93,74,0.15);}
.topic.b{background:rgba(96,165,250,0.08);color:var(--accent4);border-color:rgba(96,165,250,0.15);}
.qa{background:var(--surface);border:1px solid var(--border);border-radius:2px;margin-bottom:12px;overflow:hidden;transition:border-color 0.2s;}
.qa:hover{border-color:var(--border-hover);}
.qa-q{padding:18px 22px;cursor:pointer;display:flex;align-items:flex-start;gap:14px;user-select:none;}
.qa-n{font-family:'JetBrains Mono',monospace;font-size:0.6rem;color:var(--accent);letter-spacing:1px;flex-shrink:0;margin-top:2px;min-width:36px;}
.qa-text{font-family:'Syne',sans-serif;font-size:0.95rem;font-weight:700;color:var(--text);flex:1;line-height:1.4;}
.qa-tog{font-family:'JetBrains Mono',monospace;font-size:1.1rem;color:var(--muted);flex-shrink:0;transition:transform 0.25s,color 0.2s;margin-top:1px;}
.qa.open .qa-tog{transform:rotate(45deg);color:var(--accent);}
.qa-a{display:none;padding:4px 22px 26px 72px;border-top:1px solid var(--border);}
.qa.open .qa-a{display:block;animation:slideDown 0.25s ease;}
@keyframes slideDown{from{opacity:0;transform:translateY(-6px);}to{opacity:1;transform:translateY(0);}}
.qa-a p{font-size:0.93rem;color:rgba(226,228,240,0.85);line-height:1.95;margin-top:14px;}
.qa-a p strong{color:var(--text);font-weight:600;}
.qa-a h4{font-family:'Syne',sans-serif;font-size:0.92rem;font-weight:700;color:var(--accent);margin-top:22px;margin-bottom:8px;}
.qa-a ul{margin-top:10px;padding-left:0;list-style:none;}
.qa-a ul li{font-size:0.91rem;color:rgba(226,228,240,0.82);line-height:1.85;padding:3px 0 3px 20px;position:relative;}
.qa-a ul li::before{content:'‚Ä∫';position:absolute;left:0;color:var(--accent);font-weight:700;}
pre{background:var(--code-bg);border:1px solid var(--border);border-left:3px solid var(--accent);border-radius:2px;padding:18px 22px;margin-top:14px;overflow-x:auto;font-family:'JetBrains Mono',monospace;font-size:0.74rem;line-height:1.9;color:#c9d1e0;}
.kw{color:#f7c948;}.fn{color:#60a5fa;}.str{color:#3ecf8e;}.cm{color:#3d4460;font-style:italic;}.num{color:#f97316;}.op{color:#e85d4a;}.cons{color:#c084fc;}
.callout{border-radius:2px;padding:16px 20px;margin-top:16px;border-left:3px solid;}
.callout-title{font-family:'JetBrains Mono',monospace;font-size:0.58rem;letter-spacing:3px;text-transform:uppercase;margin-bottom:8px;}
.callout p{font-size:0.9rem;line-height:1.82;margin-top:0!important;color:var(--text)!important;opacity:0.9;}
.callout ul{margin-top:4px!important;}
.callout ul li{font-size:0.88rem!important;opacity:0.9;}
.callout.warn{background:rgba(247,201,72,0.05);border-color:var(--accent);}
.callout.warn .callout-title{color:var(--accent);}
.callout.tip{background:rgba(62,207,142,0.05);border-color:var(--accent3);}
.callout.tip .callout-title{color:var(--accent3);}
.callout.danger{background:rgba(232,93,74,0.05);border-color:var(--accent2);}
.callout.danger .callout-title{color:var(--accent2);}
.callout.info{background:rgba(96,165,250,0.05);border-color:var(--accent4);}
.callout.info .callout-title{color:var(--accent4);}
table{width:100%;border-collapse:collapse;margin-top:14px;font-family:'JetBrains Mono',monospace;font-size:0.72rem;}
th{background:rgba(247,201,72,0.08);color:var(--accent);text-align:left;padding:10px 14px;letter-spacing:2px;font-size:0.58rem;text-transform:uppercase;border:1px solid var(--border);}
td{padding:9px 14px;border:1px solid var(--border);color:var(--muted);vertical-align:top;line-height:1.6;}
td:first-child{color:var(--accent3);}
tr:hover td{background:rgba(255,255,255,0.015);}
.bottom-nav{display:flex;justify-content:space-between;align-items:center;margin-top:44px;padding-top:28px;border-top:1px solid var(--border);}
.btn{font-family:'JetBrains Mono',monospace;font-size:0.68rem;letter-spacing:2px;text-transform:uppercase;padding:11px 22px;border:1px solid var(--border);background:transparent;color:var(--muted);cursor:pointer;transition:all 0.18s;border-radius:1px;}
.btn:hover{border-color:var(--accent);color:var(--accent);background:rgba(247,201,72,0.04);}
.btn.primary{border-color:var(--accent);color:var(--accent);background:rgba(247,201,72,0.06);}
.btn.primary:hover{background:var(--accent);color:#000;}
.btn:disabled{opacity:0.25;cursor:not-allowed;}
.ov-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(210px,1fr));gap:10px;margin-top:28px;}
.ov-card{background:var(--surface);border:1px solid var(--border);border-radius:2px;padding:18px;cursor:pointer;transition:all 0.2s;position:relative;overflow:hidden;}
.ov-card::after{content:'';position:absolute;bottom:0;left:0;right:0;height:2px;background:linear-gradient(90deg,var(--accent),var(--accent2));transform:scaleX(0);transform-origin:left;transition:transform 0.3s;}
.ov-card:hover{border-color:var(--border-hover);transform:translateY(-2px);}
.ov-card:hover::after{transform:scaleX(1);}
.ov-num{font-family:'Syne',sans-serif;font-size:2.5rem;font-weight:800;color:rgba(247,201,72,0.1);line-height:1;margin-bottom:8px;letter-spacing:-2px;}
.ov-name{font-family:'Syne',sans-serif;font-size:0.9rem;font-weight:700;color:var(--text);margin-bottom:5px;line-height:1.3;}
.ov-desc{font-family:'JetBrains Mono',monospace;font-size:0.58rem;color:var(--muted);line-height:1.5;}
.ov-count{font-family:'JetBrains Mono',monospace;font-size:0.58rem;color:var(--accent);margin-top:10px;}
.cheat-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(270px,1fr));gap:12px;margin-top:24px;}
.cheat-card{background:var(--surface);border:1px solid var(--border);border-radius:2px;padding:18px;}
.cheat-card:hover{border-color:var(--border-hover);}
.cheat-title{font-family:'Syne',sans-serif;font-size:0.85rem;font-weight:800;color:var(--accent);margin-bottom:12px;}
.ci{display:flex;justify-content:space-between;align-items:flex-start;gap:8px;padding:5px 0;border-bottom:1px solid var(--border);font-family:'JetBrains Mono',monospace;font-size:0.65rem;line-height:1.4;}
.ci:last-child{border-bottom:none;}
.ci-k{color:var(--muted);flex:1;}
.ci-v{color:var(--accent3);text-align:right;flex-shrink:0;max-width:55%;}
.output-box{background:var(--code-bg);border:1px solid var(--border);border-radius:2px;padding:14px 18px;margin-top:12px;font-family:'JetBrains Mono',monospace;font-size:0.73rem;}
.output-label{font-size:0.55rem;letter-spacing:3px;color:var(--accent2);text-transform:uppercase;margin-bottom:8px;}
.output-line{color:var(--accent3);line-height:1.8;}
.output-comment{color:var(--muted);font-style:italic;}
</style>
</head>
<body>
<div class="app">
<!-- SIDEBAR -->
<nav class="sidebar">
  <div class="sidebar-brand"><div class="brand-js">JS</div><div class="brand-sub">Interview Ready ¬∑ Detailed</div></div>
  <div class="prog-wrap">
    <div class="prog-row"><span class="prog-label">Progress</span><span class="prog-pct" id="pct">0%</span></div>
    <div class="prog-track"><div class="prog-fill" id="fill"></div></div>
  </div>
  <div class="nav-group"><div class="nav-group-label"><span>‚óâ</span> Start</div>
    <div class="nav-item" data-s="overview" onclick="go('overview')"><span class="ni-dot"></span>Overview</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>1</span> Foundations</div>
    <div class="nav-item" data-s="s1" onclick="go('s1')"><span class="ni-dot"></span>JS Foundations</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>2</span> Functions</div>
    <div class="nav-item" data-s="s2" onclick="go('s2')"><span class="ni-dot"></span>Functions Deep Dive</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>3</span> This</div>
    <div class="nav-item" data-s="s3" onclick="go('s3')"><span class="ni-dot"></span>this Keyword &amp; Binding</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>4</span> Scope</div>
    <div class="nav-item" data-s="s4" onclick="go('s4')"><span class="ni-dot"></span>Scope, Hoisting &amp; Closures</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>5</span> Objects</div>
    <div class="nav-item" data-s="s5" onclick="go('s5')"><span class="ni-dot"></span>Objects &amp; Immutability</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>6</span> Arrays</div>
    <div class="nav-item" data-s="s6" onclick="go('s6')"><span class="ni-dot"></span>Array Methods &amp; Functional JS</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>7</span> Async</div>
    <div class="nav-item" data-s="s7" onclick="go('s7')"><span class="ni-dot"></span>Asynchronous JavaScript</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>8</span> Event Loop</div>
    <div class="nav-item" data-s="s8" onclick="go('s8')"><span class="ni-dot"></span>Event Loop</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>9</span> Promises</div>
    <div class="nav-item" data-s="s9" onclick="go('s9')"><span class="ni-dot"></span>Promises &amp; async/await</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>10</span> Browser</div>
    <div class="nav-item" data-s="s10" onclick="go('s10')"><span class="ni-dot"></span>Browser &amp; Events</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>11</span> Advanced</div>
    <div class="nav-item" data-s="s11" onclick="go('s11')"><span class="ni-dot"></span>Advanced Concepts</div></div>
  <div class="nav-group"><div class="nav-group-label"><span>‚òÖ</span> Final</div>
    <div class="nav-item" data-s="s12" onclick="go('s12')"><span class="ni-dot"></span>Cheat Sheet</div></div>
</nav>
<!-- MAIN -->
<main class="main">
<div class="hero">
  <div class="hero-eyebrow">Complete Detailed Course ¬∑ 2025</div>
  <h1 class="hero-title">Master<br><em>JavaScript</em><br>Interviews</h1>
  <p class="hero-desc">Deep explanations with mental models, real code patterns, and precise interview-ready answers for every concept.</p>
  <div class="hero-stats">
    <div><div class="stat-num">12</div><div class="stat-lbl">Modules</div></div>
    <div><div class="stat-num">100+</div><div class="stat-lbl">Questions</div></div>
    <div><div class="stat-num">160+</div><div class="stat-lbl">Code Examples</div></div>
    <div><div class="stat-num">‚àû</div><div class="stat-lbl">Offer Letters</div></div>
  </div>
</div>
<div class="content">

<!-- OVERVIEW -->
<div class="section active" id="sec-overview">
  <div class="section-head"><div class="sec-title" style="margin-top:0">Course Map</div></div>
  <div class="ov-grid">
    <div class="ov-card" onclick="go('s1')"><div class="ov-num">01</div><div class="ov-name">JS Foundations</div><div class="ov-desc">Execution context, call stack, variables, types, coercion</div><div class="ov-count">12 topics</div></div>
    <div class="ov-card" onclick="go('s2')"><div class="ov-num">02</div><div class="ov-name">Functions</div><div class="ov-desc">First-class, arrow functions, pure/impure, lifecycle</div><div class="ov-count">9 topics</div></div>
    <div class="ov-card" onclick="go('s3')"><div class="ov-num">03</div><div class="ov-name">this Keyword</div><div class="ov-desc">4 binding rules, call/apply/bind, lexical this</div><div class="ov-count">8 topics</div></div>
    <div class="ov-card" onclick="go('s4')"><div class="ov-num">04</div><div class="ov-name">Scope &amp; Closures</div><div class="ov-desc">Hoisting, lexical scope, closure patterns, var loop bug</div><div class="ov-count">8 topics</div></div>
    <div class="ov-card" onclick="go('s5')"><div class="ov-num">05</div><div class="ov-name">Objects &amp; Immutability</div><div class="ov-desc">References, shallow/deep copy, mutation, React impact</div><div class="ov-count">8 topics</div></div>
    <div class="ov-card" onclick="go('s6')"><div class="ov-num">06</div><div class="ov-name">Array Methods</div><div class="ov-desc">map, filter, reduce, chaining, HOF, transformations</div><div class="ov-count">7 topics</div></div>
    <div class="ov-card" onclick="go('s7')"><div class="ov-num">07</div><div class="ov-name">Async JavaScript</div><div class="ov-desc">Callbacks, promises, states, chaining, error propagation</div><div class="ov-count">8 topics</div></div>
    <div class="ov-card" onclick="go('s8')"><div class="ov-num">08</div><div class="ov-name">Event Loop</div><div class="ov-desc">Call stack, Web APIs, microtasks, macrotasks, output prediction</div><div class="ov-count">6 topics</div></div>
    <div class="ov-card" onclick="go('s9')"><div class="ov-num">09</div><div class="ov-name">Promises &amp; async/await</div><div class="ov-desc">Internals, error handling, parallel vs sequential</div><div class="ov-count">5 topics</div></div>
    <div class="ov-card" onclick="go('s10')"><div class="ov-num">10</div><div class="ov-name">Browser &amp; Events</div><div class="ov-desc">Bubbling, capturing, delegation, debounce, throttle</div><div class="ov-count">6 topics</div></div>
    <div class="ov-card" onclick="go('s11')"><div class="ov-num">11</div><div class="ov-name">Advanced Concepts</div><div class="ov-desc">Observers, rAF, Promise combinators, real-world async</div><div class="ov-count">8 topics</div></div>
    <div class="ov-card" onclick="go('s12')"><div class="ov-num">‚òÖ</div><div class="ov-name">Cheat Sheet</div><div class="ov-desc">Interview-day quick reference for every key fact</div><div class="ov-count">All concepts</div></div>
  </div>
  <div class="bottom-nav"><button class="btn" disabled>‚Üê Previous</button><button class="btn primary" onclick="go('s1')">Start Course ‚Üí</button></div>
</div>
<!-- S1: FOUNDATIONS -->
<div class="section" id="sec-s1">
  <div class="section-head"><div class="sec-num">01</div><div><div class="sec-title">JavaScript Foundations</div><div class="sec-sub">How JS actually runs your code ‚Äî the engine's perspective</div></div></div>
  <div class="topic-row"><span class="topic">Global Execution Context</span><span class="topic">Function Execution Context</span><span class="topic">Call Stack</span><span class="topic">var / let / const</span><span class="topic">TDZ</span><span class="topic r">Primitives vs References</span><span class="topic g">Truthy/Falsy</span><span class="topic b">== vs ===</span><span class="topic">typeof</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What is the Global Execution Context? Walk through exactly what JavaScript creates when a script starts.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>When the JavaScript engine first receives a script to run, the very first thing it does ‚Äî before executing a single line ‚Äî is create the <strong>Global Execution Context (GEC)</strong>. This is the top-level container where all code that isn't inside a function runs. It goes through two distinct phases:</p>
  <h4>Phase 1 ‚Äî Memory Creation (Hoisting Phase)</h4>
  <p>The engine scans the entire script and allocates memory for all declarations. Every <strong>var</strong> declaration gets memory initialized to <em>undefined</em>. Every <strong>function declaration</strong> gets its entire body stored in full. Every <strong>let/const</strong> declaration gets memory allocated but stays <em>uninitialized</em> (TDZ). No code runs yet.</p>
  <h4>Phase 2 ‚Äî Code Execution</h4>
  <p>Now the engine runs the code line by line, assigning real values and invoking functions. The GEC also creates two special bindings: <strong>the global object</strong> (<code>window</code> in browsers, <code>global</code> in Node) and a <code>this</code> reference that points to it.</p>
  <pre><span class="cm">// Engine sees the WHOLE file before executing line 1</span>
<span class="cm">// Phase 1 memory state:</span>
<span class="cm">//   name ‚Üí undefined (var hoisted)</span>
<span class="cm">//   greet ‚Üí [full function body] (function declaration hoisted)</span>
<span class="cm">//   greeting ‚Üí TDZ (let ‚Äî allocated but not initialized)</span>

<span class="kw">var</span> name = <span class="str">'Alice'</span>;        <span class="cm">// Phase 2: name ‚Üí 'Alice'</span>

<span class="kw">function</span> <span class="fn">greet</span>(person) {   <span class="cm">// Already in memory from Phase 1</span>
  <span class="kw">return</span> <span class="str">`Hello, ${person}!`</span>;
}

<span class="kw">let</span> greeting = <span class="fn">greet</span>(name); <span class="cm">// Phase 2: greeting ‚Üí 'Hello, Alice!'</span>

<span class="cm">// GEC also creates global object</span>
console.<span class="fn">log</span>(<span class="kw">this</span> === window); <span class="cm">// true in browsers</span>
console.<span class="fn">log</span>(window.name);    <span class="cm">// 'Alice' ‚Äî var declarations become global props</span></pre>
  <div class="callout tip"><div class="callout-title">üí° Interview tip</div><p>Always name both phases explicitly: "memory creation phase" and "code execution phase." This directly connects to hoisting ‚Äî one of the most common follow-up questions.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is a Function Execution Context and when is a new one created?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Every time a function is <strong>invoked</strong> (not just defined), JavaScript creates a brand-new <strong>Function Execution Context (FEC)</strong>. Calling the same function twice creates two completely separate contexts ‚Äî they share no memory. Each FEC has its own two phases.</p>
  <ul>
    <li>Its own <strong>Variable Environment</strong> ‚Äî parameters and local variables</li>
    <li>Its own <strong>arguments object</strong> ‚Äî array-like collection of arguments passed</li>
    <li>A reference to its <strong>outer lexical environment</strong> ‚Äî the scope chain, based on where the function was written</li>
    <li>Its own <strong>this</strong> binding ‚Äî determined by how the function was called</li>
  </ul>
  <p>When a function returns, its FEC is popped off the call stack and <em>destroyed</em>. Its local variables disappear ‚Äî unless a closure holds a reference to them.</p>
  <pre><span class="kw">function</span> <span class="fn">multiply</span>(x, y) {
  <span class="cm">// FEC #1 created when called with (3, 4)</span>
  <span class="cm">// Memory phase: x=3, y=4, result=undefined</span>
  <span class="kw">let</span> result = x * y;  <span class="cm">// Execution phase</span>
  <span class="kw">return</span> result;        <span class="cm">// ‚Üí 12, FEC #1 destroyed</span>
}

<span class="kw">let</span> a = <span class="fn">multiply</span>(<span class="num">3</span>, <span class="num">4</span>);  <span class="cm">// FEC #1: result=12</span>
<span class="kw">let</span> b = <span class="fn">multiply</span>(<span class="num">5</span>, <span class="num">6</span>);  <span class="cm">// FEC #2: result=30 (separate!)</span>
<span class="cm">// FEC #1's 'result' no longer exists</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is the Call Stack? How does JavaScript use it to track execution?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The <strong>call stack</strong> is a Last-In-First-Out (LIFO) data structure that tracks which execution context is currently running. The GEC sits at the bottom. Each function call pushes a new FEC on top. When a function returns, its FEC is popped. The engine always executes whatever is at the top of the stack.</p>
  <pre><span class="kw">function</span> <span class="fn">a</span>() { <span class="kw">return</span> <span class="fn">b</span>(); }
<span class="kw">function</span> <span class="fn">b</span>() { <span class="kw">return</span> <span class="fn">c</span>(); }
<span class="kw">function</span> <span class="fn">c</span>() { <span class="kw">return</span> <span class="str">'done'</span>; }

<span class="fn">a</span>();

<span class="cm">// Call stack progression (bottom ‚Üí top):</span>
<span class="cm">// [GEC]</span>
<span class="cm">// [GEC] ‚Üí [a()]            ‚Üê a() invoked</span>
<span class="cm">// [GEC] ‚Üí [a()] ‚Üí [b()]   ‚Üê b() invoked inside a</span>
<span class="cm">// [GEC] ‚Üí [a()] ‚Üí [b()] ‚Üí [c()]  ‚Üê c() invoked inside b</span>
<span class="cm">// c() returns 'done'  ‚Üí popped</span>
<span class="cm">// b() returns 'done'  ‚Üí popped</span>
<span class="cm">// a() returns 'done'  ‚Üí popped</span>
<span class="cm">// [GEC] remains until script ends</span></pre>
  <div class="callout danger"><div class="callout-title">‚ö†Ô∏è Stack Overflow</div><p>Infinite recursion (no base case) keeps pushing FECs until the stack hits its limit. The engine throws "Maximum call stack size exceeded." This is literally what a stack overflow is. Always verify your recursive function has a base case that can be reached.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">What are the differences between var, let, and const? Explain with scope and hoisting examples.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>This is one of the most common JS interview questions. Understanding <em>why</em> the differences exist matters more than memorizing them.</p>
  <table>
    <tr><th></th><th>var</th><th>let</th><th>const</th></tr>
    <tr><td>Scope</td><td>Function-scoped (leaks from blocks)</td><td>Block-scoped (stays in {})</td><td>Block-scoped (stays in {})</td></tr>
    <tr><td>Hoisting</td><td>Hoisted ‚Üí initialized as undefined</td><td>Hoisted ‚Üí TDZ (uninitialized)</td><td>Hoisted ‚Üí TDZ (uninitialized)</td></tr>
    <tr><td>Re-declaration</td><td>Allowed (silent overwrite)</td><td>SyntaxError</td><td>SyntaxError</td></tr>
    <tr><td>Re-assignment</td><td>Allowed</td><td>Allowed</td><td>TypeError</td></tr>
    <tr><td>Global object prop</td><td>Yes ‚Äî window.x</td><td>No</td><td>No</td></tr>
  </table>
  <pre><span class="cm">// var ‚Äî function-scoped, leaks out of blocks</span>
<span class="kw">function</span> <span class="fn">demo</span>() {
  <span class="kw">if</span> (<span class="kw">true</span>) {
    <span class="kw">var</span> leaked = <span class="str">'I escaped the block!'</span>;
    <span class="kw">let</span> contained = <span class="str">'I stay here'</span>;
  }
  console.<span class="fn">log</span>(leaked);    <span class="cm">// 'I escaped the block!' ‚Äî leaks out</span>
  console.<span class="fn">log</span>(contained); <span class="cm">// ReferenceError ‚Äî let is block-scoped</span>
}

<span class="cm">// const ‚Äî binding is immutable, but the VALUE can mutate</span>
<span class="kw">const</span> num = <span class="num">42</span>;
num = <span class="num">100</span>;      <span class="cm">// TypeError: Assignment to constant variable</span>

<span class="kw">const</span> arr = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>];
arr.<span class="fn">push</span>(<span class="num">4</span>);   <span class="cm">// ‚úÖ OK ‚Äî arr still points to same array</span>
arr = [<span class="num">4</span>, <span class="num">5</span>];  <span class="cm">// ‚ùå TypeError ‚Äî binding is const</span>

<span class="cm">// var re-declaration ‚Äî silently dangerous</span>
<span class="kw">var</span> user = <span class="str">'Alice'</span>;
<span class="kw">var</span> user = <span class="str">'Bob'</span>;    <span class="cm">// No error ‚Äî silently overwrites!</span>

<span class="cm">// let/const prevent re-declaration</span>
<span class="kw">let</span> score = <span class="num">10</span>;
<span class="kw">let</span> score = <span class="num">20</span>;   <span class="cm">// SyntaxError: 'score' has already been declared</span></pre>
  <div class="callout tip"><div class="callout-title">üí° Best Practice</div><p>Default to <strong>const</strong> for everything. Use <strong>let</strong> only when you need to reassign (loop counters, conditional assignment). <strong>Never use var</strong> in modern code ‚Äî its function-scoping and silent re-declaration create subtle, hard-to-track bugs.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">What is the Temporal Dead Zone? Why does it exist?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The <strong>Temporal Dead Zone (TDZ)</strong> is the time between when a <code>let</code> or <code>const</code> variable is hoisted into memory at block start and when code execution reaches the declaration line. During this window, the variable exists in memory but is <em>uninitialized</em>. Any read or write throws a <code>ReferenceError</code>.</p>
  <p>The TDZ is <em>intentional</em>. With <code>var</code>, accessing before declaration gives <code>undefined</code>, hiding bugs silently. The TDZ makes the same mistake throw an immediate, visible error ‚Äî forcing "declare before use" discipline.</p>
  <pre><span class="cm">// TDZ for 'score' begins at the START of this block ‚Üì</span>
{
  console.<span class="fn">log</span>(score); <span class="cm">// ‚ùå ReferenceError: Cannot access 'score' before initialization</span>
  <span class="kw">let</span> score = <span class="num">100</span>;    <span class="cm">// ‚Üê TDZ ends here (declaration line)</span>
  console.<span class="fn">log</span>(score); <span class="cm">// ‚úÖ 100</span>
}

<span class="cm">// Compare with var (no TDZ, no error, just undefined ‚Äî confusing)</span>
console.<span class="fn">log</span>(points); <span class="cm">// undefined ‚Äî hoisted and initialized</span>
<span class="kw">var</span> points = <span class="num">50</span>;

<span class="cm">// TDZ even when an outer variable exists with same name</span>
<span class="kw">let</span> x = <span class="str">'outer'</span>;
{
  <span class="cm">// TDZ for inner x starts here ‚Äî outer x is shadowed but inaccessible</span>
  console.<span class="fn">log</span>(x); <span class="cm">// ‚ùå ReferenceError (NOT 'outer'!)</span>
  <span class="kw">let</span> x = <span class="str">'inner'</span>;
}</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.06</span><span class="qa-text">What is the difference between primitive and reference types? How does memory work for each?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>JavaScript has two categories of types and they behave fundamentally differently in memory. This distinction underlies copying bugs, equality confusion, and mutation errors.</p>
  <h4>Primitive Types ‚Äî Stored by Value</h4>
  <p><code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>symbol</code>, <code>bigint</code> ‚Äî stored directly in the variable on the stack. Copying creates an independent duplicate. Primitives are <em>immutable</em> ‚Äî you can't change the string "hello", you can only create a new string.</p>
  <h4>Reference Types ‚Äî Stored by Reference</h4>
  <p>Objects, arrays, and functions are allocated on the <em>heap</em>. The variable holds a <em>memory address</em> pointing to where the data lives. Copying a reference copies the address ‚Äî both variables now point to the same heap location.</p>
  <pre><span class="cm">// Primitives ‚Äî independent copies</span>
<span class="kw">let</span> a = <span class="num">42</span>;
<span class="kw">let</span> b = a;      <span class="cm">// b gets a copy of 42</span>
b = <span class="num">100</span>;
console.<span class="fn">log</span>(a, b); <span class="cm">// 42, 100 ‚Äî completely separate</span>

<span class="cm">// References ‚Äî shared object</span>
<span class="kw">let</span> obj1 = { score: <span class="num">100</span> };
<span class="kw">let</span> obj2 = obj1;     <span class="cm">// obj2 holds the SAME address</span>
obj2.score = <span class="num">999</span>;
console.<span class="fn">log</span>(obj1.score); <span class="cm">// 999 ‚Äî obj1 sees the change!</span>

<span class="cm">// Equality checks address, not content</span>
<span class="kw">const</span> arr1 = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>];
<span class="kw">const</span> arr2 = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]; <span class="cm">// different allocation</span>
<span class="kw">const</span> arr3 = arr1;       <span class="cm">// same address</span>
arr1 === arr2;  <span class="cm">// false ‚Äî different addresses</span>
arr1 === arr3;  <span class="cm">// true  ‚Äî same address</span>

<span class="cm">// Reassigning vs mutating</span>
<span class="kw">let</span> arr = [<span class="num">1</span>, <span class="num">2</span>];
<span class="kw">let</span> ref = arr;
ref = [<span class="num">9</span>, <span class="num">8</span>];      <span class="cm">// reassigns ref to a NEW array</span>
console.<span class="fn">log</span>(arr);  <span class="cm">// [1, 2] ‚Äî original untouched</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.07</span><span class="qa-text">What are truthy and falsy values? Name all falsy values and common interview traps.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>In boolean contexts (if statements, ternary, <code>&&</code>, <code>||</code>), JavaScript coerces values. There are exactly <strong>8 falsy values</strong> ‚Äî everything else is truthy. Interviewers love testing edge cases here.</p>
  <pre><span class="cm">// The 8 falsy values ‚Äî memorize these</span>
<span class="kw">false</span>         <span class="cm">// boolean false</span>
<span class="num">0</span>             <span class="cm">// number zero</span>
<span class="num">-0</span>            <span class="cm">// negative zero (yes, JS has this)</span>
<span class="num">0n</span>            <span class="cm">// BigInt zero</span>
<span class="str">''</span>            <span class="cm">// empty string (both '' and "")</span>
<span class="kw">null</span>
<span class="kw">undefined</span>
<span class="kw">NaN</span>           <span class="cm">// Not a Number</span>

<span class="cm">// Everything else is truthy ‚Äî including these TRAPS:</span>
<span class="str">'0'</span>           <span class="cm">// string "0" ‚Üí TRUTHY (non-empty string)</span>
<span class="str">'false'</span>       <span class="cm">// string "false" ‚Üí TRUTHY</span>
[]            <span class="cm">// empty array ‚Üí TRUTHY (it's an object)</span>
{}            <span class="cm">// empty object ‚Üí TRUTHY</span>
<span class="kw">function</span>(){}  <span class="cm">// any function ‚Üí TRUTHY</span>
<span class="num">-1</span>            <span class="cm">// any non-zero number ‚Üí TRUTHY</span>
<span class="str">' '</span>           <span class="cm">// whitespace string ‚Üí TRUTHY</span>

<span class="cm">// Practical patterns</span>
<span class="kw">const</span> name = <span class="str">''</span>;
<span class="kw">const</span> display = name || <span class="str">'Anonymous'</span>;    <span class="cm">// 'Anonymous' ‚Äî '' is falsy</span>

<span class="cm">// ?? (nullish coalescing) vs || (OR)</span>
<span class="kw">const</span> count = <span class="num">0</span>;
count || <span class="str">'default'</span>;   <span class="cm">// 'default' ‚Äî 0 is falsy</span>
count ?? <span class="str">'default'</span>;   <span class="cm">// 0 ‚Äî ?? only triggers on null/undefined, not 0</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.08</span><span class="qa-text">What is the difference between == and ===? When would you ever use ==?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><code>===</code> (strict equality) compares both type and value with no coercion. <code>==</code> (loose equality) first converts both values to a common type using complex rules, then compares. The coercion algorithm is unintuitive and leads to bugs.</p>
  <pre><span class="cm">// === ‚Äî no surprises</span>
<span class="num">5</span> === <span class="num">5</span>         <span class="cm">// true</span>
<span class="num">5</span> === <span class="str">'5'</span>       <span class="cm">// false ‚Äî number vs string, done</span>
<span class="kw">null</span> === <span class="kw">undefined</span> <span class="cm">// false ‚Äî different types</span>

<span class="cm">// == ‚Äî coercion surprises</span>
<span class="num">5</span> == <span class="str">'5'</span>        <span class="cm">// true  ‚Äî string '5' ‚Üí number 5</span>
<span class="num">0</span> == <span class="kw">false</span>      <span class="cm">// true  ‚Äî false ‚Üí 0</span>
<span class="num">0</span> == <span class="str">''</span>         <span class="cm">// true  ‚Äî '' ‚Üí 0</span>
<span class="str">''</span> == <span class="kw">false</span>     <span class="cm">// true  ‚Äî both ‚Üí 0</span>
<span class="kw">null</span> == <span class="kw">undefined</span> <span class="cm">// true  ‚Äî special rule</span>
<span class="kw">null</span> == <span class="num">0</span>       <span class="cm">// false ‚Äî null ONLY equals null or undefined</span>
<span class="kw">null</span> == <span class="kw">false</span>   <span class="cm">// false</span>
[] == ![]       <span class="cm">// true  ‚Äî classic interview trap!</span>

<span class="cm">// The ONE valid use of == in modern code:</span>
<span class="cm">// Check for both null AND undefined simultaneously</span>
<span class="kw">if</span> (value == <span class="kw">null</span>) { <span class="cm">// catches null and undefined</span>
  <span class="fn">setDefault</span>();
}
<span class="cm">// Equivalent to: if (value === null || value === undefined)</span></pre>
  <div class="callout danger"><div class="callout-title">üö® Rule</div><p>Always use <code>===</code>. The <code>==</code> coercion rules are too complex and inconsistent to rely on. The one exception is <code>val == null</code> to check for both null and undefined, but even that can be replaced with explicit checks.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.09</span><span class="qa-text">What are the quirks of typeof? How do you actually check for null, arrays, and NaN?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><code>typeof</code> returns a string describing the type of its operand. It works as expected for most types, but has several infamous quirks every JS developer must know.</p>
  <pre><span class="cm">// Predictable results</span>
<span class="kw">typeof</span> <span class="str">'hello'</span>     <span class="cm">// 'string'</span>
<span class="kw">typeof</span> <span class="num">42</span>          <span class="cm">// 'number'</span>
<span class="kw">typeof</span> <span class="kw">true</span>        <span class="cm">// 'boolean'</span>
<span class="kw">typeof</span> <span class="kw">undefined</span>   <span class="cm">// 'undefined'</span>
<span class="kw">typeof</span> Symbol()    <span class="cm">// 'symbol'</span>
<span class="kw">typeof</span> <span class="num">42n</span>         <span class="cm">// 'bigint'</span>
<span class="kw">typeof</span> <span class="kw">function</span>(){} <span class="cm">// 'function' (special case)</span>

<span class="cm">// ‚ö†Ô∏è Famous quirks ‚Äî interviewers love these</span>
<span class="kw">typeof</span> <span class="kw">null</span>       <span class="cm">// 'object' ‚Üê historic bug, never fixed for compatibility</span>
<span class="kw">typeof</span> []         <span class="cm">// 'object' ‚Üê arrays are objects</span>
<span class="kw">typeof</span> {}         <span class="cm">// 'object'</span>
<span class="kw">typeof</span> <span class="kw">NaN</span>        <span class="cm">// 'number' ‚Üê NaN has type 'number'!</span>

<span class="cm">// typeof is safe on undeclared variables (won't throw)</span>
<span class="kw">typeof</span> notDeclared  <span class="cm">// 'undefined' (safe)</span>
notDeclared         <span class="cm">// ReferenceError if accessed directly</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ Correct ways to check types ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// Null:</span>
x === <span class="kw">null</span>                  <span class="cm">// ‚úÖ only way</span>

<span class="cm">// Array:</span>
Array.<span class="fn">isArray</span>([])             <span class="cm">// ‚úÖ true</span>
Array.<span class="fn">isArray</span>({})             <span class="cm">// false</span>

<span class="cm">// Plain object (not null, not array):</span>
<span class="kw">typeof</span> x === <span class="str">'object'</span> && x !== <span class="kw">null</span> && !Array.<span class="fn">isArray</span>(x)

<span class="cm">// NaN:</span>
Number.<span class="fn">isNaN</span>(<span class="kw">NaN</span>)    <span class="cm">// ‚úÖ true (strict, no coercion)</span>
<span class="fn">isNaN</span>(<span class="str">'hello'</span>)     <span class="cm">// ‚ö†Ô∏è true (global isNaN coerces string ‚Üí NaN)</span>
Number.<span class="fn">isNaN</span>(<span class="str">'hello'</span>) <span class="cm">// false (no coercion ‚Äî safer)</span></pre></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('overview')">‚Üê Overview</button><button class="btn primary" onclick="go('s2')">Functions ‚Üí</button></div>
</div>
<!-- S2: FUNCTIONS -->
<div class="section" id="sec-s2">
  <div class="section-head"><div class="sec-num">02</div><div><div class="sec-title">Functions</div><div class="sec-sub">The building blocks ‚Äî from definitions to first-class citizens</div></div></div>
  <div class="topic-row"><span class="topic">Why Functions Exist</span><span class="topic">Invocation vs Definition</span><span class="topic">Execution Lifecycle</span><span class="topic">Declaration vs Expression</span><span class="topic">Parameters vs Arguments</span><span class="topic">return behavior</span><span class="topic g">First-Class Citizens</span><span class="topic g">Arrow Functions</span><span class="topic r">Pure vs Impure</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">Why do functions exist? What fundamental problems do they solve?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Functions are far more than just "reusable code." Understanding why they exist makes you a better developer and helps you write cleaner architecture.</p>
  <h4>1. Reusability (DRY ‚Äî Don't Repeat Yourself)</h4>
  <p>Write logic once, call it anywhere. When the logic changes, update it in one place rather than hunting down every copy-paste.</p>
  <h4>2. Abstraction ‚Äî Hide Complexity Behind a Name</h4>
  <p>When you call <code>validateEmail(email)</code>, you don't need to know the regex or the validation rules ‚Äî you just use the interface. Functions let you think at higher levels of abstraction.</p>
  <h4>3. Decomposition ‚Äî Break Problems Into Manageable Pieces</h4>
  <p>Complex problems become solvable when broken into small, single-purpose functions. Each function does one thing well ‚Äî this is the Single Responsibility Principle in practice.</p>
  <h4>4. Encapsulation ‚Äî Create Private Scope</h4>
  <p>Variables inside a function are private to it. This prevents naming collisions with other code and accidental mutation of shared state. Closures take this further.</p>
  <pre><span class="cm">// Without functions: repetitive, fragile, unmaintainable</span>
<span class="kw">let</span> area1 = <span class="num">3.14159</span> * <span class="num">5</span> * <span class="num">5</span>;
<span class="kw">let</span> area2 = <span class="num">3.14159</span> * <span class="num">10</span> * <span class="num">10</span>;
<span class="cm">// What if you need to use Math.PI instead? Update every line.</span>

<span class="cm">// With functions: change once, works everywhere</span>
<span class="kw">function</span> <span class="fn">circleArea</span>(radius) {
  <span class="kw">return</span> Math.PI * radius ** <span class="num">2</span>;
}
<span class="kw">const</span> area1 = <span class="fn">circleArea</span>(<span class="num">5</span>);
<span class="kw">const</span> area2 = <span class="fn">circleArea</span>(<span class="num">10</span>);</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is the difference between function invocation and definition?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><strong>Definition</strong> is describing what a function does ‚Äî writing the recipe. The code inside doesn't run. The function is simply stored as a value in memory. <strong>Invocation</strong> is actually executing it ‚Äî cooking the meal. This creates a new FEC, binds arguments to parameters, runs the code, and returns a value.</p>
  <pre><span class="cm">// Definition ‚Äî nothing executes, just stored in memory</span>
<span class="kw">function</span> <span class="fn">sendEmail</span>(to, subject) {
  console.<span class="fn">log</span>(<span class="str">`Sending "${subject}" to ${to}`</span>); <span class="cm">// not running yet</span>
}

<span class="cm">// Invocation ‚Äî code runs NOW, new FEC created each time</span>
<span class="fn">sendEmail</span>(<span class="str">'alice@example.com'</span>, <span class="str">'Hello'</span>); <span class="cm">// FEC #1</span>
<span class="fn">sendEmail</span>(<span class="str">'bob@example.com'</span>, <span class="str">'Hi'</span>);    <span class="cm">// FEC #2 ‚Äî completely separate</span>

<span class="cm">// A function reference doesn't invoke it</span>
<span class="kw">const</span> ref = sendEmail;  <span class="cm">// stored reference ‚Äî no invocation</span>
<span class="fn">ref</span>(<span class="str">'c@d.com'</span>, <span class="str">'test'</span>); <span class="cm">// NOW invoked via the reference</span>

<span class="cm">// Common mistake: passing without calling vs passing a call</span>
setTimeout(sendEmail, <span class="num">1000</span>);            <span class="cm">// ‚Üê passes the function (correct)</span>
setTimeout(<span class="fn">sendEmail</span>(<span class="str">'...'</span>, <span class="str">'...'</span>), <span class="num">1000</span>); <span class="cm">// ‚Üê calls it immediately, passes result</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is the complete function execution lifecycle?</span><span class="qa-tog">+</span></div>
  <div class="qa-a">
  <ul>
    <li><strong>Step 1:</strong> Function is invoked ‚Üí new FEC pushed onto call stack</li>
    <li><strong>Step 2:</strong> Memory phase ‚Äî parameters assigned argument values, local <code>var</code>s hoisted to <code>undefined</code>, <code>let/const</code> in TDZ</li>
    <li><strong>Step 3:</strong> <code>this</code> binding determined by call-site (how the function was invoked)</li>
    <li><strong>Step 4:</strong> Code executes line by line</li>
    <li><strong>Step 5:</strong> <code>return</code> statement hit (or end of function) ‚Üí return value produced (<code>undefined</code> if no return)</li>
    <li><strong>Step 6:</strong> FEC popped off call stack and <em>destroyed</em> ‚Äî local variables gone (unless closed over)</li>
  </ul>
  <pre><span class="kw">function</span> <span class="fn">process</span>(items, threshold) {
  <span class="cm">// Step 2: items=[...], threshold=10, result=undefined (var), total in TDZ (let)</span>
  <span class="cm">// Step 3: this = global (plain call)</span>
  <span class="kw">var</span> result = [];
  <span class="kw">let</span> total = <span class="num">0</span>;          <span class="cm">// Step 4: TDZ ends, total=0</span>
  <span class="kw">for</span> (<span class="kw">const</span> item <span class="kw">of</span> items) {
    <span class="kw">if</span> (item > threshold) {
      result.<span class="fn">push</span>(item);
      total += item;
    }
  }
  <span class="kw">return</span> { result, total }; <span class="cm">// Step 5: return value</span>
}                            <span class="cm">// Step 6: FEC destroyed</span>

<span class="kw">const</span> output = <span class="fn">process</span>([<span class="num">5</span>, <span class="num">15</span>, <span class="num">8</span>, <span class="num">20</span>], <span class="num">10</span>);
<span class="cm">// output = { result: [15, 20], total: 35 }</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">What is the difference between function declaration and function expression?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The key difference is <strong>hoisting</strong>. Function declarations are fully hoisted ‚Äî name and body ‚Äî so you can call them before they appear in source code. Function expressions are not (or only the variable name is, but not the function value).</p>
  <table>
    <tr><th></th><th>Function Declaration</th><th>Function Expression</th></tr>
    <tr><td>Syntax</td><td>function name() {}</td><td>const f = function() {}</td></tr>
    <tr><td>Hoisting</td><td>Fully hoisted ‚Äî callable anywhere in scope</td><td>Only binding hoisted, function not</td></tr>
    <tr><td>Use before definition</td><td>Yes</td><td>No ‚Äî ReferenceError or TypeError</td></tr>
    <tr><td>Name in errors</td><td>Named in stack traces</td><td>Anonymous unless named</td></tr>
  </table>
  <pre><span class="cm">// Declaration ‚Äî works before the definition line</span>
<span class="fn">greet</span>(<span class="str">'Alice'</span>);  <span class="cm">// ‚úÖ 'Hello, Alice' ‚Äî fully hoisted</span>
<span class="kw">function</span> <span class="fn">greet</span>(name) { <span class="kw">return</span> <span class="str">`Hello, ${name}`</span>; }

<span class="cm">// const expression ‚Äî cannot use before definition (TDZ)</span>
<span class="fn">sayBye</span>(<span class="str">'Alice'</span>);  <span class="cm">// ‚ùå ReferenceError</span>
<span class="kw">const</span> <span class="fn">sayBye</span> = <span class="kw">function</span>(name) { <span class="kw">return</span> <span class="str">`Bye, ${name}`</span>; };

<span class="cm">// var expression ‚Äî dangerous: TypeError (var is undefined, not a fn)</span>
<span class="fn">runIt</span>();  <span class="cm">// ‚ùå TypeError: runIt is not a function</span>
<span class="kw">var</span> <span class="fn">runIt</span> = <span class="kw">function</span>() {};

<span class="cm">// Named function expression ‚Äî name only accessible INSIDE</span>
<span class="kw">const</span> <span class="fn">factorial</span> = <span class="kw">function</span> <span class="fn">fact</span>(n) {
  <span class="kw">return</span> n &lt;= <span class="num">1</span> ? <span class="num">1</span> : n * <span class="fn">fact</span>(n - <span class="num">1</span>); <span class="cm">// can call itself</span>
};
<span class="fn">factorial</span>(<span class="num">5</span>); <span class="cm">// 120 ‚Äî called by outer name</span>
<span class="cm">// fact(5); ‚Äî ReferenceError (name not in outer scope)</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">Parameters vs arguments ‚Äî what happens with missing or extra ones?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><strong>Parameters</strong> are the named placeholders in the function definition. <strong>Arguments</strong> are the actual values passed at call time. JavaScript is flexible: passing fewer arguments leaves parameters as <code>undefined</code>; extra arguments are ignored (but accessible via <code>arguments</code> or rest params).</p>
  <pre><span class="kw">function</span> <span class="fn">greet</span>(firstName, lastName, title) {
  console.<span class="fn">log</span>(firstName, lastName, title);
}

<span class="fn">greet</span>(<span class="str">'Alice'</span>, <span class="str">'Smith'</span>, <span class="str">'Dr.'</span>);  <span class="cm">// 'Alice' 'Smith' 'Dr.'</span>
<span class="fn">greet</span>(<span class="str">'Bob'</span>);                      <span class="cm">// 'Bob' undefined undefined</span>
<span class="fn">greet</span>(<span class="str">'Carol'</span>, <span class="str">'Jones'</span>, <span class="str">'Ms.'</span>, <span class="str">'extra'</span>); <span class="cm">// 'extra' ignored silently</span>

<span class="cm">// ES6 default parameters ‚Äî cleaner than old || trick</span>
<span class="kw">function</span> <span class="fn">connect</span>(host = <span class="str">'localhost'</span>, port = <span class="num">8080</span>, secure = <span class="kw">false</span>) {
  <span class="kw">return</span> <span class="str">`${secure ? 'https' : 'http'}://${host}:${port}`</span>;
}
<span class="fn">connect</span>();                    <span class="cm">// 'http://localhost:8080'</span>
<span class="fn">connect</span>(<span class="str">'api.example.com'</span>);  <span class="cm">// 'http://api.example.com:8080'</span>
<span class="fn">connect</span>(<span class="str">'example.com'</span>, <span class="num">443</span>, <span class="kw">true</span>); <span class="cm">// 'https://example.com:443'</span>
<span class="cm">// undefined triggers default, null does NOT</span>
<span class="fn">connect</span>(<span class="kw">undefined</span>, <span class="num">3000</span>);    <span class="cm">// 'http://localhost:3000'</span>
<span class="fn">connect</span>(<span class="kw">null</span>, <span class="num">3000</span>);         <span class="cm">// 'http://null:3000' ‚Äî null doesn't trigger default!</span>

<span class="cm">// Rest parameters ‚Äî collect all remaining args into a real array</span>
<span class="kw">function</span> <span class="fn">sum</span>(label, ...numbers) {  <span class="cm">// numbers is a real Array</span>
  <span class="kw">const</span> total = numbers.<span class="fn">reduce</span>((acc, n) => acc + n, <span class="num">0</span>);
  <span class="kw">return</span> <span class="str">`${label}: ${total}`</span>;
}
<span class="fn">sum</span>(<span class="str">'Total'</span>, <span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>); <span class="cm">// 'Total: 10'</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.06</span><span class="qa-text">What does it mean that functions are first-class citizens?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>In programming language theory, a <strong>first-class citizen</strong> is a value that can be used anywhere any other value can be used. In JavaScript, functions are values ‚Äî they can be assigned to variables, passed as arguments, returned from other functions, and stored in data structures. This enables the entire functional programming paradigm.</p>
  <pre><span class="cm">// 1. Assigned to a variable (function expression)</span>
<span class="kw">const</span> <span class="fn">double</span> = n => n * <span class="num">2</span>;

<span class="cm">// 2. Stored in an object (method)</span>
<span class="kw">const</span> math = { <span class="fn">add</span>: (a, b) => a + b, <span class="fn">sub</span>: (a, b) => a - b };

<span class="cm">// 3. Stored in an array</span>
<span class="kw">const</span> pipeline = [String, Number, Boolean];
pipeline.<span class="fn">map</span>(fn => <span class="fn">fn</span>(<span class="str">'42'</span>)); <span class="cm">// ['42', 42, true]</span>

<span class="cm">// 4. Passed as argument (callback / higher-order function)</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="fn">map</span>(n => n * <span class="num">2</span>);          <span class="cm">// arrow fn passed to .map()</span>
setTimeout(<span class="fn">double</span>, <span class="num">1000</span>);             <span class="cm">// double passed to setTimeout</span>

<span class="cm">// 5. Returned from a function (factory / closure)</span>
<span class="kw">function</span> <span class="fn">makeMultiplier</span>(factor) {
  <span class="kw">return</span> n => n * factor;  <span class="cm">// returns a new function</span>
}
<span class="kw">const</span> <span class="fn">triple</span> = <span class="fn">makeMultiplier</span>(<span class="num">3</span>);
<span class="fn">triple</span>(<span class="num">7</span>); <span class="cm">// 21</span>

<span class="cm">// 6. Composition ‚Äî functions that compose other functions</span>
<span class="kw">const</span> <span class="fn">compose</span> = (f, g) => x => <span class="fn">f</span>(<span class="fn">g</span>(x));
<span class="kw">const</span> <span class="fn">doubleSquare</span> = <span class="fn">compose</span>(x => x * <span class="num">2</span>, x => x * x);
<span class="fn">doubleSquare</span>(<span class="num">3</span>); <span class="cm">// 18 (square first ‚Üí 9, then double ‚Üí 18)</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.07</span><span class="qa-text">How are arrow functions different from regular functions? When should you use each?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Arrow functions are not just "shorter syntax." They have fundamentally different behavior that determines when to use them.</p>
  <table>
    <tr><th>Feature</th><th>Regular Function</th><th>Arrow Function</th></tr>
    <tr><td>this binding</td><td>Dynamic ‚Äî set at call time</td><td>Lexical ‚Äî inherited from enclosing scope</td></tr>
    <tr><td>arguments object</td><td>Has its own</td><td>None ‚Äî use rest params (...args)</td></tr>
    <tr><td>new keyword</td><td>Can construct</td><td>Cannot ‚Äî throws TypeError</td></tr>
    <tr><td>prototype property</td><td>Has it</td><td>None</td></tr>
    <tr><td>Implicit return</td><td>No</td><td>Yes (single expression, no braces)</td></tr>
    <tr><td>Hoisting</td><td>Full (if declaration)</td><td>Always expression ‚Äî no hoisting</td></tr>
  </table>
  <pre><span class="cm">// Arrow function forms</span>
<span class="kw">const</span> <span class="fn">add</span>     = (a, b) => a + b;          <span class="cm">// implicit return</span>
<span class="kw">const</span> <span class="fn">square</span>  = x => x * x;              <span class="cm">// single param (no parens)</span>
<span class="kw">const</span> <span class="fn">greet</span>   = () => <span class="str">'hello'</span>;           <span class="cm">// no params</span>
<span class="kw">const</span> <span class="fn">getUser</span> = () => ({ name: <span class="str">'Alice'</span> }); <span class="cm">// return object: wrap in ()</span>
<span class="kw">const</span> <span class="fn">log</span>     = x => { console.<span class="fn">log</span>(x); }; <span class="cm">// body block: explicit return</span>

<span class="cm">// ‚úÖ USE arrows for:</span>
<span class="cm">// Callbacks and array methods</span>
[<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>].<span class="fn">filter</span>(n => n > <span class="num">1</span>).<span class="fn">map</span>(n => n * <span class="num">2</span>);

<span class="cm">// Preserving 'this' in class methods</span>
<span class="kw">class</span> Timer {
  <span class="fn">constructor</span>() { <span class="kw">this</span>.ticks = <span class="num">0</span>; }
  <span class="fn">start</span>() {
    setInterval(() => {
      <span class="kw">this</span>.ticks++; <span class="cm">// ‚úÖ 'this' = Timer instance (lexical)</span>
    }, <span class="num">1000</span>);
  }
}

<span class="cm">// ‚ùå DON'T use arrows for:</span>
<span class="cm">// Object methods ‚Äî 'this' won't be the object</span>
<span class="kw">const</span> user = {
  name: <span class="str">'Alice'</span>,
  <span class="fn">greet</span>: () => <span class="str">`Hi, ${<span class="kw">this</span>.name}`</span>  <span class="cm">// 'this' = window, NOT user!</span>
};
user.<span class="fn">greet</span>(); <span class="cm">// 'Hi, undefined'</span>

<span class="cm">// Constructor functions</span>
<span class="kw">const</span> Animal = (species) => { <span class="kw">this</span>.species = species; };
<span class="kw">new</span> <span class="fn">Animal</span>(<span class="str">'cat'</span>); <span class="cm">// ‚ùå TypeError: Animal is not a constructor</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.08</span><span class="qa-text">What is the difference between pure and impure functions? Why does it matter for React?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>pure function</strong> satisfies two rules: (1) same input always gives same output, and (2) no observable side effects ‚Äî it doesn't modify anything outside itself. An <strong>impure function</strong> breaks one or both rules.</p>
  <h4>What counts as a side effect?</h4>
  <ul>
    <li>Modifying outer scope variables or global state</li>
    <li>Mutating arguments (especially objects/arrays)</li>
    <li>Making network requests (fetch, axios)</li>
    <li>Writing to DOM or console</li>
    <li>Reading Date.now(), Math.random(), or any external state</li>
  </ul>
  <pre><span class="cm">// ‚úÖ Pure functions</span>
<span class="kw">const</span> <span class="fn">add</span> = (a, b) => a + b;
<span class="kw">const</span> <span class="fn">getInitials</span> = name => name.<span class="fn">split</span>(<span class="str">' '</span>).<span class="fn">map</span>(w => w[<span class="num">0</span>]).<span class="fn">join</span>(<span class="str">'.'</span>);
<span class="kw">const</span> <span class="fn">doubled</span> = arr => arr.<span class="fn">map</span>(x => x * <span class="num">2</span>); <span class="cm">// returns new array</span>

<span class="cm">// ‚ùå Impure functions</span>
<span class="kw">let</span> total = <span class="num">0</span>;
<span class="kw">const</span> <span class="fn">addToTotal</span> = n => total += n;    <span class="cm">// modifies external state</span>

<span class="kw">const</span> <span class="fn">mutate</span> = (arr, item) => {
  arr.<span class="fn">push</span>(item); <span class="kw">return</span> arr;          <span class="cm">// mutates its argument!</span>
};

<span class="kw">const</span> <span class="fn">rand</span> = () => Math.<span class="fn">random</span>();    <span class="cm">// different result each call</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ Why this matters for React ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// React expects components to be pure: same props ‚Üí same output</span>

<span class="cm">// ‚ùå Impure component ‚Äî depends on external mutable state</span>
<span class="kw">let</span> callCount = <span class="num">0</span>;
<span class="kw">function</span> <span class="fn">Counter</span>() {
  callCount++;  <span class="cm">// side effect during render! breaks React</span>
  <span class="kw">return</span> &lt;div&gt;{callCount}&lt;/div&gt;;
}

<span class="cm">// ‚úÖ Pure component ‚Äî all data from props or state</span>
<span class="kw">function</span> <span class="fn">Counter</span>({ count }) {
  <span class="kw">return</span> &lt;div&gt;{count}&lt;/div&gt;; <span class="cm">// same props ‚Üí same render</span>
}</pre>
  <div class="callout tip"><div class="callout-title">üí° Mental Model</div><p>Think of pure functions as mathematical functions ‚Äî <code>f(x) = x¬≤ + 1</code> always gives the same result for the same x, and doesn't change anything in the world. Pure functions are <strong>testable</strong> (no setup needed), <strong>predictable</strong> (no surprises), and <strong>cacheable</strong> (memoization works perfectly).</p></div></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s1')">‚Üê Foundations</button><button class="btn primary" onclick="go('s3')">this Keyword ‚Üí</button></div>
</div>
<!-- S3: THIS -->
<div class="section" id="sec-s3">
  <div class="section-head"><div class="sec-num">03</div><div><div class="sec-title">this Keyword &amp; Binding</div><div class="sec-sub">The most misunderstood concept in JavaScript ‚Äî fully demystified</div></div></div>
  <div class="topic-row"><span class="topic">Call-time Binding</span><span class="topic">Global Context</span><span class="topic">Normal Calls</span><span class="topic">Object Methods</span><span class="topic r">Losing this</span><span class="topic g">Lexical this</span><span class="topic">call()</span><span class="topic">apply()</span><span class="topic">bind()</span><span class="topic b">Callbacks &amp; Events</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What is call-time binding? How are the four binding rules prioritized?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The golden rule: <strong>in regular functions, <code>this</code> is determined when the function is called, not when it's defined.</strong> This is called "call-time binding" or "dynamic binding." The same function can have a different <code>this</code> depending on how it's invoked. Four rules determine <code>this</code>, in priority order (highest wins):</p>
  <h4>Rule 1 ‚Äî new Binding (highest priority)</h4>
  <p>Called with <code>new</code>: a brand new object is created, <code>this</code> = that new object, and it's returned automatically.</p>
  <h4>Rule 2 ‚Äî Explicit Binding</h4>
  <p>Called with <code>call()</code>, <code>apply()</code>, or <code>bind()</code>: <code>this</code> = whatever you pass as the first argument.</p>
  <h4>Rule 3 ‚Äî Implicit Binding</h4>
  <p>Called as an object method (<code>obj.fn()</code>): <code>this</code> = the object to the left of the dot.</p>
  <h4>Rule 4 ‚Äî Default Binding (lowest priority)</h4>
  <p>Plain function call: <code>this</code> = global object (<code>window</code>) in non-strict mode, <code>undefined</code> in strict mode.</p>
  <pre><span class="kw">function</span> <span class="fn">show</span>() { console.<span class="fn">log</span>(<span class="kw">this</span>?.name || <span class="kw">this</span>); }

<span class="cm">// Rule 4: Default ‚Äî no object, no explicit, no new</span>
<span class="fn">show</span>();                          <span class="cm">// window (or undefined in strict)</span>

<span class="cm">// Rule 3: Implicit ‚Äî object to the left of dot</span>
<span class="kw">const</span> alice = { name: <span class="str">'Alice'</span>, show };
alice.<span class="fn">show</span>();                    <span class="cm">// 'Alice'</span>

<span class="cm">// Rule 2: Explicit ‚Äî call/apply/bind</span>
<span class="kw">const</span> bob = { name: <span class="str">'Bob'</span> };
<span class="fn">show</span>.<span class="fn">call</span>(bob);                  <span class="cm">// 'Bob'</span>

<span class="cm">// Rule 1: new ‚Äî creates a fresh object</span>
<span class="kw">function</span> <span class="fn">User</span>(name) { <span class="kw">this</span>.name = name; }
<span class="kw">const</span> carol = <span class="kw">new</span> <span class="fn">User</span>(<span class="str">'Carol'</span>); <span class="cm">// this = new User object</span>
carol.name; <span class="cm">// 'Carol'</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is 'this' in the global context and in plain function calls?</span><span class="qa-tog">+</span></div>
  <div class="qa-a">
  <pre><span class="cm">// Global context ‚Äî at the top level</span>
console.<span class="fn">log</span>(<span class="kw">this</span>);          <span class="cm">// Browser: window | Node REPL: global | Node module: {}</span>
<span class="kw">this</span>.greeting = <span class="str">'hello'</span>;
console.<span class="fn">log</span>(window.greeting); <span class="cm">// 'hello' ‚Äî this === window in browser top-level</span>

<span class="cm">// Plain function call ‚Äî default binding rule</span>
<span class="kw">function</span> <span class="fn">whoAmI</span>() {
  console.<span class="fn">log</span>(<span class="kw">this</span>);         <span class="cm">// non-strict: window | strict: undefined</span>
}
<span class="fn">whoAmI</span>(); <span class="cm">// no object context, no explicit binding, no new ‚Üí default</span>

<span class="cm">// Strict mode changes default to undefined</span>
<span class="str">'use strict'</span>;
<span class="kw">function</span> <span class="fn">strictFn</span>() {
  console.<span class="fn">log</span>(<span class="kw">this</span>);  <span class="cm">// undefined (not window)</span>
  <span class="kw">return</span> <span class="kw">this</span>.name;   <span class="cm">// TypeError: Cannot read 'name' of undefined</span>
}
<span class="fn">strictFn</span>();

<span class="cm">// class methods are automatically strict</span>
<span class="kw">class</span> Demo {
  <span class="fn">test</span>() { console.<span class="fn">log</span>(<span class="kw">this</span>); }
}
<span class="kw">const</span> d = <span class="kw">new</span> <span class="fn">Demo</span>();
<span class="kw">const</span> { test } = d;
<span class="fn">test</span>();  <span class="cm">// undefined ‚Äî class methods are strict by default</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is 'this' inside object methods? Explain the implicit binding rule in depth.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>When a function is called as a method ‚Äî using dot notation ‚Äî <code>this</code> is the object that "owns" the call at that moment. Specifically: <code>this</code> = the object to the <em>left of the dot</em> at <em>call time</em>. Not where the function was defined. Where it was <em>called from</em>.</p>
  <pre><span class="kw">const</span> car = {
  brand: <span class="str">'Toyota'</span>,
  speed: <span class="num">0</span>,
  <span class="fn">accelerate</span>(amount) {
    <span class="kw">this</span>.speed += amount;  <span class="cm">// this = car (left of dot)</span>
    <span class="kw">return</span> <span class="kw">this</span>.speed;
  },
  <span class="fn">info</span>() {
    <span class="kw">return</span> <span class="str">`${<span class="kw">this</span>.brand} going ${<span class="kw">this</span>.speed}mph`</span>;
  }
};

car.<span class="fn">accelerate</span>(<span class="num">30</span>); <span class="cm">// this = car ‚Üí car.speed = 30</span>
car.<span class="fn">info</span>();          <span class="cm">// 'Toyota going 30mph'</span>

<span class="cm">// Only the IMMEDIATE object matters</span>
<span class="kw">const</span> company = {
  name: <span class="str">'ACME'</span>,
  department: {
    name: <span class="str">'Engineering'</span>,
    <span class="fn">show</span>() { <span class="kw">return</span> <span class="kw">this</span>.name; }
  }
};
company.department.<span class="fn">show</span>(); <span class="cm">// 'Engineering' ‚Äî this = department (immediate)</span>

<span class="cm">// Method chaining ‚Äî return this to chain</span>
<span class="kw">const</span> query = {
  filters: [],
  <span class="fn">where</span>(cond) { <span class="kw">this</span>.filters.<span class="fn">push</span>(cond); <span class="kw">return</span> <span class="kw">this</span>; },
  <span class="fn">limit</span>(n) { <span class="kw">this</span>._limit = n; <span class="kw">return</span> <span class="kw">this</span>; },
  <span class="fn">build</span>() { <span class="kw">return</span> <span class="str">`WHERE ${<span class="kw">this</span>.filters.<span class="fn">join</span>(<span class="str">' AND '</span>)} LIMIT ${<span class="kw">this</span>._limit}`</span>; }
};
query.<span class="fn">where</span>(<span class="str">'age > 18'</span>).<span class="fn">where</span>(<span class="str">'active = 1'</span>).<span class="fn">limit</span>(<span class="num">10</span>).<span class="fn">build</span>();
<span class="cm">// 'WHERE age > 18 AND active = 1 LIMIT 10'</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">What does "losing this" mean? Walk through every scenario and fix.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>"Losing <code>this</code>" happens when a method is detached from its object and called as a plain function. Without an object context, default binding kicks in (global or undefined). This is one of the most common real-world JavaScript bugs.</p>
  <pre><span class="kw">const</span> user = {
  name: <span class="str">'Alice'</span>,
  <span class="fn">greet</span>() { <span class="kw">return</span> <span class="str">`Hi, I'm ${<span class="kw">this</span>.name}`</span>; }
};

<span class="cm">// ‚úÖ Correct method call</span>
user.<span class="fn">greet</span>();  <span class="cm">// "Hi, I'm Alice"</span>

<span class="cm">// ‚ùå Scenario 1: Extracted to a variable</span>
<span class="kw">const</span> fn = user.greet;
<span class="fn">fn</span>();           <span class="cm">// "Hi, I'm undefined" ‚Äî this lost</span>

<span class="cm">// ‚ùå Scenario 2: Passed as callback</span>
setTimeout(user.greet, <span class="num">1000</span>);  <span class="cm">// this lost ‚Äî called as plain fn</span>

<span class="cm">// ‚ùå Scenario 3: Destructured</span>
<span class="kw">const</span> { greet } = user;
<span class="fn">greet</span>();       <span class="cm">// this lost</span>

<span class="cm">// ‚ùå Scenario 4: Passed to higher-order function</span>
<span class="kw">const</span> methods = [user.greet];
methods[<span class="num">0</span>]();  <span class="cm">// this = methods array, not user</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ FIXES ‚îÄ‚îÄ‚îÄ</span>

<span class="cm">// Fix 1: Arrow wrapper ‚Äî keep calling as method</span>
setTimeout(() => user.<span class="fn">greet</span>(), <span class="num">1000</span>);  <span class="cm">// ‚úÖ user.greet() keeps context</span>

<span class="cm">// Fix 2: bind() ‚Äî permanently bind this</span>
<span class="kw">const</span> boundGreet = user.greet.<span class="fn">bind</span>(user);
setTimeout(boundGreet, <span class="num">1000</span>);  <span class="cm">// ‚úÖ</span>

<span class="cm">// Fix 3: Arrow method in class ‚Äî permanently bound to instance</span>
<span class="kw">class</span> User {
  <span class="fn">constructor</span>(name) { <span class="kw">this</span>.name = name; }
  <span class="fn">greet</span> = () => <span class="str">`Hi, I'm ${<span class="kw">this</span>.name}`</span>; <span class="cm">// class field arrow</span>
}
<span class="kw">const</span> u = <span class="kw">new</span> <span class="fn">User</span>(<span class="str">'Bob'</span>);
<span class="kw">const</span> extracted = u.greet;
<span class="fn">extracted</span>();  <span class="cm">// ‚úÖ "Hi, I'm Bob" ‚Äî arrow always has correct this</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">How do arrow functions handle 'this'? Explain lexical this thoroughly.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Arrow functions <em>do not bind their own <code>this</code></em>. When an arrow function is created, it captures the <code>this</code> value from the surrounding lexical scope ‚Äî the code that <em>contains</em> the arrow function at definition time. This is called <strong>lexical this</strong>, and it can never be changed ‚Äî not by <code>call()</code>, <code>apply()</code>, <code>bind()</code>, or method invocation. The captured <code>this</code> is locked in.</p>
  <pre><span class="cm">// Regular function: this determined at call-time</span>
<span class="kw">const</span> obj = {
  val: <span class="num">42</span>,
  <span class="fn">regularMethod</span>() {
    <span class="cm">// 'this' here = obj (via implicit binding)</span>
    <span class="kw">const</span> inner = <span class="kw">function</span>() {
      <span class="cm">// 'this' here = global/undefined (plain call ‚Äî inner loses context)</span>
      console.<span class="fn">log</span>(<span class="kw">this</span>.val);  <span class="cm">// undefined or TypeError</span>
    };
    <span class="fn">inner</span>();
  },
  <span class="fn">arrowMethod</span>() {
    <span class="cm">// 'this' here = obj (implicit binding of arrowMethod)</span>
    <span class="kw">const</span> inner = () => {
      <span class="cm">// arrow captures 'this' from arrowMethod = obj</span>
      console.<span class="fn">log</span>(<span class="kw">this</span>.val);  <span class="cm">// 42 ‚úÖ</span>
    };
    <span class="fn">inner</span>();
  }
};

<span class="cm">// Arrow this cannot be changed even with call/apply/bind</span>
<span class="kw">const</span> arrow = () => <span class="kw">this</span>;
arrow.<span class="fn">call</span>({ name: <span class="str">'override'</span> });  <span class="cm">// still window ‚Äî binding ignored</span>
arrow.<span class="fn">bind</span>({ name: <span class="str">'override'</span> })(); <span class="cm">// still window ‚Äî bind ignored</span>

<span class="cm">// Common use case: class + async</span>
<span class="kw">class</span> DataService {
  <span class="fn">constructor</span>() {
    <span class="kw">this</span>.data = [];
    <span class="kw">this</span>.loading = <span class="kw">false</span>;
  }
  <span class="kw">async</span> <span class="fn">fetchAll</span>() {
    <span class="kw">this</span>.loading = <span class="kw">true</span>;                <span class="cm">// this = DataService instance</span>
    <span class="kw">const</span> items = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/items'</span>).<span class="fn">then</span>(r => r.<span class="fn">json</span>());
    <span class="cm">// Arrow preserves 'this' across await boundaries</span>
    items.<span class="fn">forEach</span>(item => {
      <span class="kw">this</span>.data.<span class="fn">push</span>(item); <span class="cm">// ‚úÖ still DataService instance</span>
    });
    <span class="kw">this</span>.loading = <span class="kw">false</span>;
  }
}</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.06</span><span class="qa-text">Explain call(), apply(), and bind() with real examples. When do you use each?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>All three live on <code>Function.prototype</code> and allow you to explicitly set <code>this</code>. They're how you implement explicit binding.</p>
  <table>
    <tr><th>Method</th><th>Executes</th><th>Arguments</th><th>Use when</th></tr>
    <tr><td>call(ctx, a, b)</td><td>Immediately</td><td>Individual (spread)</td><td>Known number of args, call once</td></tr>
    <tr><td>apply(ctx, [a, b])</td><td>Immediately</td><td>Array</td><td>Args already in array form</td></tr>
    <tr><td>bind(ctx, a, b)</td><td>Returns new fn</td><td>Pre-filled (partial)</td><td>Need a reusable bound function</td></tr>
  </table>
  <pre><span class="kw">function</span> <span class="fn">introduce</span>(role, company) {
  <span class="kw">return</span> <span class="str">`I'm ${<span class="kw">this</span>.name}, ${role} at ${company}`</span>;
}

<span class="kw">const</span> alice = { name: <span class="str">'Alice'</span> };
<span class="kw">const</span> bob   = { name: <span class="str">'Bob'</span> };

<span class="cm">// call() ‚Äî execute now, args spread</span>
<span class="fn">introduce</span>.<span class="fn">call</span>(alice, <span class="str">'Engineer'</span>, <span class="str">'Google'</span>); <span class="cm">// "I'm Alice, Engineer at Google"</span>
<span class="fn">introduce</span>.<span class="fn">call</span>(bob, <span class="str">'Designer'</span>, <span class="str">'Meta'</span>);    <span class="cm">// "I'm Bob, Designer at Meta"</span>

<span class="cm">// apply() ‚Äî execute now, args as array</span>
<span class="kw">const</span> args = [<span class="str">'Manager'</span>, <span class="str">'Apple'</span>];
<span class="fn">introduce</span>.<span class="fn">apply</span>(alice, args);  <span class="cm">// "I'm Alice, Manager at Apple"</span>

<span class="cm">// apply() classic use: Math.max with array</span>
<span class="kw">const</span> nums = [<span class="num">3</span>, <span class="num">1</span>, <span class="num">4</span>, <span class="num">1</span>, <span class="num">5</span>, <span class="num">9</span>];
Math.<span class="fn">max</span>.<span class="fn">apply</span>(<span class="kw">null</span>, nums);  <span class="cm">// 9 (pre-spread syntax way)</span>
Math.<span class="fn">max</span>(...nums);           <span class="cm">// 9 (modern ‚Äî prefer spread)</span>

<span class="cm">// bind() ‚Äî returns NEW function, executes later</span>
<span class="kw">const</span> aliceIntro = <span class="fn">introduce</span>.<span class="fn">bind</span>(alice);
<span class="fn">aliceIntro</span>(<span class="str">'CTO'</span>, <span class="str">'Startup'</span>);    <span class="cm">// "I'm Alice, CTO at Startup"</span>
<span class="fn">aliceIntro</span>(<span class="str">'Founder'</span>, <span class="str">'Acme'</span>);  <span class="cm">// "I'm Alice, Founder at Acme"</span>

<span class="cm">// bind() partial application ‚Äî pre-fill some args</span>
<span class="kw">const</span> aliceEngineer = <span class="fn">introduce</span>.<span class="fn">bind</span>(alice, <span class="str">'Engineer'</span>);
<span class="fn">aliceEngineer</span>(<span class="str">'Google'</span>);  <span class="cm">// "I'm Alice, Engineer at Google"</span>
<span class="fn">aliceEngineer</span>(<span class="str">'Netflix'</span>); <span class="cm">// "I'm Alice, Engineer at Netflix"</span>

<span class="cm">// Real-world bind(): event handler with context</span>
<span class="kw">class</span> Button {
  <span class="fn">constructor</span>(label) { <span class="kw">this</span>.label = label; }
  <span class="fn">handleClick</span>() { console.<span class="fn">log</span>(<span class="str">`Clicked: ${<span class="kw">this</span>.label}`</span>); }
  <span class="fn">attach</span>(el) {
    el.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, <span class="kw">this</span>.handleClick.<span class="fn">bind</span>(<span class="kw">this</span>));
  }
}</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.07</span><span class="qa-text">How does 'this' behave in callbacks and DOM event handlers?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>When you pass a method as a callback, it loses its object context ‚Äî it's called as a plain function by whatever is invoking the callback. DOM event handlers have a special rule: <code>this</code> inside a regular function handler = the element that fired the event.</p>
  <pre><span class="cm">// In array callbacks</span>
<span class="kw">const</span> team = {
  name: <span class="str">'Dev Team'</span>,
  members: [<span class="str">'Alice'</span>, <span class="str">'Bob'</span>, <span class="str">'Carol'</span>],
  <span class="fn">printRoster</span>() {
    <span class="cm">// ‚ùå regular callback ‚Äî 'this' is not team</span>
    <span class="kw">this</span>.members.<span class="fn">forEach</span>(<span class="kw">function</span>(member) {
      console.<span class="fn">log</span>(<span class="kw">this</span>.name, member); <span class="cm">// undefined, member (strict)</span>
    });

    <span class="cm">// ‚úÖ arrow callback ‚Äî lexically inherits 'this' from printRoster</span>
    <span class="kw">this</span>.members.<span class="fn">forEach</span>(member => {
      console.<span class="fn">log</span>(<span class="kw">this</span>.name, member); <span class="cm">// 'Dev Team', member ‚úÖ</span>
    });

    <span class="cm">// ‚úÖ forEach second arg ‚Äî explicit thisArg</span>
    <span class="kw">this</span>.members.<span class="fn">forEach</span>(<span class="kw">function</span>(member) {
      console.<span class="fn">log</span>(<span class="kw">this</span>.name, member);
    }, <span class="kw">this</span>);  <span class="cm">// pass 'this' as second arg to forEach</span>
  }
};

<span class="cm">// In DOM event handlers</span>
<span class="kw">const</span> btn = document.<span class="fn">querySelector</span>(<span class="str">'#myBtn'</span>);

<span class="cm">// Regular function: this = the element</span>
btn.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, <span class="kw">function</span>(e) {
  console.<span class="fn">log</span>(<span class="kw">this</span>);             <span class="cm">// the button element</span>
  console.<span class="fn">log</span>(<span class="kw">this</span> === e.currentTarget); <span class="cm">// true</span>
  <span class="kw">this</span>.<span class="fn">classList</span>.<span class="fn">toggle</span>(<span class="str">'active'</span>); <span class="cm">// modify the button</span>
});

<span class="cm">// Arrow: this = outer scope (class instance, module, etc.)</span>
<span class="kw">class</span> Form {
  <span class="fn">constructor</span>() {
    <span class="kw">this</span>.fields = {};
    document.<span class="fn">getElementById</span>(<span class="str">'submit'</span>)
      .<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
        e.<span class="fn">preventDefault</span>();
        <span class="kw">this</span>.<span class="fn">submit</span>(); <span class="cm">// ‚úÖ 'this' = Form instance</span>
      });
  }
  <span class="fn">submit</span>() { console.<span class="fn">log</span>(<span class="str">'Submitting...'</span>); }
}</pre></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s2')">‚Üê Functions</button><button class="btn primary" onclick="go('s4')">Scope &amp; Closures ‚Üí</button></div>
</div>
<!-- S4: SCOPE & CLOSURES -->
<div class="section" id="sec-s4">
  <div class="section-head"><div class="sec-num">04</div><div><div class="sec-title">Scope, Hoisting &amp; Closures</div><div class="sec-sub">The engine's memory model ‚Äî what's accessible where and why</div></div></div>
  <div class="topic-row"><span class="topic">Global Scope</span><span class="topic">Function Scope</span><span class="topic">Block Scope</span><span class="topic">Hoisting var</span><span class="topic">Hoisting let/const</span><span class="topic">Lexical Scoping</span><span class="topic g">Closure</span><span class="topic g">Memory Preservation</span><span class="topic g">References</span><span class="topic r">var in Loops</span><span class="topic r">Isolated State</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">Explain global scope, function scope, and block scope. What problem does each solve?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><strong>Scope</strong> is the region of code where a variable is accessible. JavaScript has three scoping levels, each more granular than the last.</p>
  <h4>Global Scope</h4>
  <p>Variables at the top level of a script. Accessible anywhere. <code>var</code> globals also become <code>window</code> properties. Problem: global state can be accidentally overwritten from anywhere ‚Äî globals are the enemy of maintainable code.</p>
  <h4>Function Scope</h4>
  <p><code>var</code> inside a function ‚Äî scoped to that function. Provides privacy for function-local logic. Before ES6, this was the ONLY way to create private variables. The IIFE pattern exploited this to avoid polluting global scope.</p>
  <h4>Block Scope</h4>
  <p><code>let</code> and <code>const</code> inside any <code>{}</code> ‚Äî scoped to that block. This is how most languages work and what you almost always want. <code>var</code> ignores blocks entirely and leaks to the enclosing function.</p>
  <pre><span class="cm">// Global scope</span>
<span class="kw">var</span> globalVar = <span class="str">'global var'</span>;    <span class="cm">// accessible everywhere + window.globalVar</span>
<span class="kw">let</span> globalLet = <span class="str">'global let'</span>;    <span class="cm">// accessible everywhere, NOT window.globalLet</span>
<span class="kw">const</span> PI = <span class="num">3.14159</span>;              <span class="cm">// accessible everywhere</span>

<span class="cm">// Function scope</span>
<span class="kw">function</span> <span class="fn">calculate</span>() {
  <span class="kw">var</span> localVar = <span class="str">'only in calculate'</span>;

  <span class="kw">if</span> (<span class="kw">true</span>) {
    <span class="kw">var</span> blockVar = <span class="str">'var leaks to function!'</span>; <span class="cm">// NOT block-scoped</span>
    <span class="kw">let</span> blockLet = <span class="str">'stays in block'</span>;         <span class="cm">// block-scoped ‚úÖ</span>
    <span class="kw">const</span> blockConst = <span class="str">'also stays'</span>;         <span class="cm">// block-scoped ‚úÖ</    console.log(blockLet);   // ‚úÖ accessible here</span>
  }

  console.<span class="fn">log</span>(localVar);  <span class="cm">// ‚úÖ</span>
  console.<span class="fn">log</span>(blockVar);  <span class="cm">// ‚úÖ 'var leaks to function!' ‚Äî dangerous!</span>
  console.<span class="fn">log</span>(blockLet);  <span class="cm">// ‚ùå ReferenceError ‚Äî not in this scope</span>
}

console.<span class="fn">log</span>(localVar); <span class="cm">// ‚ùå ReferenceError ‚Äî outside function</span>

<span class="cm">// Block scope in practice</span>
<span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {  <span class="cm">// i is block-scoped to the for loop</span>
  console.<span class="fn">log</span>(i);
}
<span class="cm">// console.log(i);  // ‚ùå ReferenceError</span>

<span class="kw">for</span> (<span class="kw">var</span> j = <span class="num">0</span>; j &lt; <span class="num">3</span>; j++) {  <span class="cm">// j escapes!</span>
  console.<span class="fn">log</span>(j);
}
console.<span class="fn">log</span>(j); <span class="cm">// 3 ‚Äî j leaked into the outer scope</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">How does hoisting work for var, let/const, and function declarations? What's the mental model?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Hoisting is the result of the <em>memory creation phase</em>. The JS engine scans the scope for declarations before running any code, allocating memory for them. But hoisting moves the <em>declaration</em>, never the <em>assignment</em>. And different declaration types are initialized differently when hoisted.</p>
  <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ var hoisting ‚Äî initialized to undefined ‚îÄ‚îÄ‚îÄ</span>
console.<span class="fn">log</span>(x); <span class="cm">// undefined (hoisted + initialized)</span>
<span class="kw">var</span> x = <span class="num">5</span>;
console.<span class="fn">log</span>(x); <span class="cm">// 5</span>

<span class="cm">// What the engine sees mentally:</span>
<span class="kw">var</span> x;           <span class="cm">// declaration hoisted, value = undefined</span>
console.<span class="fn">log</span>(x); <span class="cm">// undefined</span>
x = <span class="num">5</span>;           <span class="cm">// assignment stays in place</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ let/const hoisting ‚Äî TDZ (not initialized) ‚îÄ‚îÄ‚îÄ</span>
console.<span class="fn">log</span>(y); <span class="cm">// ‚ùå ReferenceError: Cannot access 'y' before initialization</span>
<span class="kw">let</span> y = <span class="num">10</span>;
console.<span class="fn">log</span>(y); <span class="cm">// 10</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ Function declarations ‚Äî fully hoisted ‚îÄ‚îÄ‚îÄ</span>
<span class="fn">sayHi</span>();  <span class="cm">// ‚úÖ works ‚Äî entire body hoisted</span>
<span class="kw">function</span> <span class="fn">sayHi</span>() { console.<span class="fn">log</span>(<span class="str">'Hi!'</span>); }
<span class="fn">sayHi</span>();  <span class="cm">// ‚úÖ works after too</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ Function expressions ‚Äî only the var is hoisted ‚îÄ‚îÄ‚îÄ</span>
<span class="fn">sayBye</span>(); <span class="cm">// ‚ùå TypeError: sayBye is not a function</span>
<span class="cm">// var sayBye is hoisted as undefined; calling undefined() = TypeError</span>
<span class="kw">var</span> <span class="fn">sayBye</span> = <span class="kw">function</span>() { console.<span class="fn">log</span>(<span class="str">'Bye!'</span>); };

<span class="cm">// const expression ‚Äî TDZ error</span>
<span class="fn">run</span>();    <span class="cm">// ‚ùå ReferenceError ‚Äî const in TDZ</span>
<span class="kw">const</span> <span class="fn">run</span> = <span class="kw">function</span>() {};

<span class="cm">// Practical implication: prefer function declarations for utility helpers</span>
<span class="cm">// they can be called before they're defined in long files</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is lexical scoping? How does the scope chain work?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><strong>Lexical scoping</strong> means a variable's accessible scope is determined by <em>where the code is written</em> in the source file ‚Äî not where it's called at runtime. When JS resolves a variable name, it searches outward through parent scopes ‚Äî this chain of scopes is the <strong>scope chain</strong>, established at function-creation time based on the written structure of the code.</p>
  <pre><span class="kw">let</span> global = <span class="str">'G'</span>;

<span class="kw">function</span> <span class="fn">outer</span>() {
  <span class="kw">let</span> outerVar = <span class="str">'O'</span>;

  <span class="kw">function</span> <span class="fn">middle</span>() {
    <span class="kw">let</span> middleVar = <span class="str">'M'</span>;

    <span class="kw">function</span> <span class="fn">inner</span>() {
      <span class="kw">let</span> innerVar = <span class="str">'I'</span>;
      <span class="cm">// Scope chain lookup for outerVar:</span>
      <span class="cm">// 1. Check inner's scope ‚Üí not found</span>
      <span class="cm">// 2. Check middle's scope ‚Üí not found</span>
      <span class="cm">// 3. Check outer's scope ‚Üí FOUND 'O'</span>
      console.<span class="fn">log</span>(innerVar, middleVar, outerVar, global);
      <span class="cm">// 'I', 'M', 'O', 'G'</span>
    }
    <span class="fn">inner</span>();
  }
  <span class="fn">middle</span>();
}

<span class="cm">// "Where written" ‚Äî not "where called"</span>
<span class="kw">let</span> x = <span class="str">'global x'</span>;

<span class="kw">function</span> <span class="fn">createFn</span>() {
  <span class="kw">let</span> x = <span class="str">'local x'</span>;         <span class="cm">// written HERE</span>
  <span class="kw">return</span> () => console.<span class="fn">log</span>(x);  <span class="cm">// captures 'local x' at creation</span>
}

<span class="kw">const</span> fn = <span class="fn">createFn</span>();
fn(); <span class="cm">// 'local x' ‚Äî even though called in global scope</span>
<span class="cm">// The arrow was written inside createFn, so it sees createFn's x</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">What is a closure? Give a precise definition, mental model, and real use cases.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>closure</strong> is a function that retains access to its lexical scope ‚Äî the variables from the surrounding scope where it was created ‚Äî even after that outer scope has finished executing and its execution context has been destroyed.</p>
  <p>Closures are not a special syntax. They're a natural consequence of two features combined: <em>lexical scoping</em> + <em>first-class functions</em>. Whenever a function references variables from its outer scope and is used beyond that scope's lifetime, a closure forms automatically.</p>
  <pre><span class="cm">// Basic closure</span>
<span class="kw">function</span> <span class="fn">createCounter</span>() {
  <span class="kw">let</span> count = <span class="num">0</span>;          <span class="cm">// lives in createCounter's scope</span>

  <span class="kw">return</span> <span class="kw">function</span>() {
    count++;               <span class="cm">// inner fn closes over 'count'</span>
    <span class="kw">return</span> count;
  };
}

<span class="kw">const</span> counter = <span class="fn">createCounter</span>();
<span class="cm">// createCounter's FEC is gone from the call stack</span>
<span class="cm">// BUT 'count' is kept alive because 'counter' holds a reference</span>
counter(); <span class="cm">// 1</span>
counter(); <span class="cm">// 2</span>
counter(); <span class="cm">// 3  ‚Äî count persists!</span>

<span class="cm">// Real-world closures</span>

<span class="cm">// 1. Data privacy / module pattern</span>
<span class="kw">function</span> <span class="fn">createAccount</span>(initial) {
  <span class="kw">let</span> balance = initial;           <span class="cm">// PRIVATE ‚Äî only accessible via methods</span>
  <span class="kw">return</span> {
    <span class="fn">deposit</span>(n)   { balance += n; <span class="kw">return</span> balance; },
    <span class="fn">withdraw</span>(n)  {
      <span class="kw">if</span> (n > balance) <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="str">'NSF'</span>);
      balance -= n; <span class="kw">return</span> balance;
    },
    <span class="fn">getBalance</span>() { <span class="kw">return</span> balance; }
  };
}
<span class="kw">const</span> acct = <span class="fn">createAccount</span>(<span class="num">1000</span>);
acct.<span class="fn">deposit</span>(<span class="num">500</span>);    <span class="cm">// 1500</span>
acct.balance;          <span class="cm">// undefined ‚Äî truly private!</span>

<span class="cm">// 2. Memoization ‚Äî cache expensive results</span>
<span class="kw">function</span> <span class="fn">memoize</span>(fn) {
  <span class="kw">const</span> cache = {};   <span class="cm">// private cache, persists via closure</span>
  <span class="kw">return</span> <span class="kw">function</span>(...args) {
    <span class="kw">const</span> key = JSON.<span class="fn">stringify</span>(args);
    <span class="kw">if</span> (cache[key]) <span class="kw">return</span> cache[key];
    cache[key] = <span class="fn">fn</span>(...args);
    <span class="kw">return</span> cache[key];
  };
}
<span class="kw">const</span> <span class="fn">expensiveFib</span> = <span class="fn">memoize</span>(n => n &lt;= <span class="num">1</span> ? n : <span class="fn">expensiveFib</span>(n-<span class="num">1</span>) + <span class="fn">expensiveFib</span>(n-<span class="num">2</span>));</pre>
  <div class="callout tip"><div class="callout-title">üí° Mental Model</div><p>Think of a closure as a "backpack." When the inner function is created, it packs the variables it needs from the surrounding scope into this backpack. No matter where the function later goes or how it's called, it always has access to what's in its backpack.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">Why do closures hold references, not copies? What are the implications?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Closures capture a <strong>live reference to the variable binding</strong> ‚Äî not a snapshot of the value at closure creation time. If the variable changes after the closure forms, the closure sees the new value. This is powerful but also the source of the infamous loop bug.</p>
  <pre><span class="cm">// All closures share the SAME variable</span>
<span class="kw">function</span> <span class="fn">makeShared</span>() {
  <span class="kw">let</span> count = <span class="num">0</span>;
  <span class="kw">const</span> <span class="fn">inc</span> = () => ++count;
  <span class="kw">const</span> <span class="fn">dec</span> = () => --count;
  <span class="kw">const</span> <span class="fn">get</span> = () => count;
  <span class="kw">return</span> { inc, dec, get };
}
<span class="kw">const</span> s = <span class="fn">makeShared</span>();
s.<span class="fn">inc</span>(); s.<span class="fn">inc</span>(); s.<span class="fn">dec</span>();
s.<span class="fn">get</span>(); <span class="cm">// 1 ‚Äî all three share the SAME 'count' reference</span>

<span class="cm">// Delayed access sees the LATEST value</span>
<span class="kw">function</span> <span class="fn">delayedLog</span>() {
  <span class="kw">let</span> msg = <span class="str">'initial'</span>;
  setTimeout(() => console.<span class="fn">log</span>(msg), <span class="num">1000</span>); <span class="cm">// captures reference</span>
  msg = <span class="str">'changed!'</span>;  <span class="cm">// changes BEFORE timeout fires</span>
}
<span class="fn">delayedLog</span>(); <span class="cm">// After 1s: logs 'changed!' (not 'initial')</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.06</span><span class="qa-text">Explain the classic var-in-loop closure bug. Why does it happen? Give 3 fixes.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>This is the most famous closure interview question. Two concepts combine to create the bug: (1) <code>var</code> is function-scoped, so all loop iterations share the same <code>i</code> variable, and (2) closures hold references to variables, not copies. By the time the setTimeout callbacks run, the loop has ended and <code>i</code> is 3.</p>
  <pre><span class="cm">// ‚ùå THE BUG ‚Äî all callbacks share ONE 'i'</span>
<span class="kw">for</span> (<span class="kw">var</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
  setTimeout(() => console.<span class="fn">log</span>(i), <span class="num">100</span>);
}
<span class="cm">// Output: 3, 3, 3 (not 0, 1, 2)</span>
<span class="cm">// Why: loop ends with i=3, then callbacks run and all read i=3</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ FIX 1: let ‚Äî block-scoped, NEW variable per iteration ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
  setTimeout(() => console.<span class="fn">log</span>(i), <span class="num">100</span>);
}
<span class="cm">// Output: 0, 1, 2 ‚úÖ</span>
<span class="cm">// Why: 'let' creates a BRAND NEW 'i' binding for each loop iteration</span>
<span class="cm">// Each callback captures a different 'i'</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ FIX 2: IIFE ‚Äî create new scope, capture current value ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">for</span> (<span class="kw">var</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
  ((<span class="fn">j</span>) => setTimeout(() => console.<span class="fn">log</span>(j), <span class="num">100</span>))(i);
}
<span class="cm">// Output: 0, 1, 2 ‚úÖ</span>
<span class="cm">// Why: IIFE executes immediately with i's current value as 'j'</span>
<span class="cm">// Each IIFE creates a new scope with its own 'j'</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ FIX 3: bind() ‚Äî pre-fill the argument ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">for</span> (<span class="kw">var</span> i = <span class="num">0</span>; i &lt; <span class="num">3</span>; i++) {
  setTimeout(console.log.<span class="fn">bind</span>(<span class="kw">null</span>, i), <span class="num">100</span>);
}
<span class="cm">// Output: 0, 1, 2 ‚úÖ</span>
<span class="cm">// Why: bind captures i's current value as a pre-filled argument</span></pre>
  <div class="callout warn"><div class="callout-title">‚ö° Top Interview Question</div><p>Memorize the answer to: (1) <em>why</em> it outputs 3,3,3 ‚Äî <code>var</code> creates one binding shared across all iterations; (2) at least two different fixes; (3) <em>why</em> each fix works. The explanation of the root cause is more impressive than just knowing the fix.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.07</span><span class="qa-text">How do multiple closures maintain isolated state?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Each call to an outer function creates a completely new execution context with its own set of variables. Closures returned from separate calls close over separate, independent environments. They never share state unless you explicitly share a variable between them.</p>
  <pre><span class="kw">function</span> <span class="fn">makeCounter</span>(name, start = <span class="num">0</span>) {
  <span class="kw">let</span> count = start;        <span class="cm">// each call gets its OWN 'count'</span>
  <span class="kw">return</span> {
    <span class="fn">increment</span>() { count++; },
    <span class="fn">reset</span>()     { count = start; },
    <span class="fn">value</span>()     { <span class="kw">return</span> <span class="str">`${name}: ${count}`</span>; }
  };
}

<span class="cm">// Three separate closures, three separate environments</span>
<span class="kw">const</span> visitors = <span class="fn">makeCounter</span>(<span class="str">'Visitors'</span>, <span class="num">1000</span>);  <span class="cm">// count‚ÇÅ = 1000</span>
<span class="kw">const</span> clicks    = <span class="fn">makeCounter</span>(<span class="str">'Clicks'</span>);          <span class="cm">// count‚ÇÇ = 0</span>
<span class="kw">const</span> errors    = <span class="fn">makeCounter</span>(<span class="str">'Errors'</span>);          <span class="cm">// count‚ÇÉ = 0</span>

visitors.<span class="fn">increment</span>(); visitors.<span class="fn">increment</span>();
clicks.<span class="fn">increment</span>();

visitors.<span class="fn">value</span>();  <span class="cm">// 'Visitors: 1002'</span>
clicks.<span class="fn">value</span>();    <span class="cm">// 'Clicks: 1'</span>
errors.<span class="fn">value</span>();    <span class="cm">// 'Errors: 0' ‚Äî unaffected</span>

<span class="cm">// React analogy: each component instance gets its own useState closure</span>
<span class="cm">// const [count, setCount] = useState(0);</span>
<span class="cm">// Two instances of the same component have isolated state ‚Äî same mechanism!</span></pre></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s3')">‚Üê this Keyword</button><button class="btn primary" onclick="go('s5')">Objects &amp; Immutability ‚Üí</button></div>
</div>
<!-- S5: OBJECTS & IMMUTABILITY -->
<div class="section" id="sec-s5">
  <div class="section-head"><div class="sec-num">05</div><div><div class="sec-title">Objects &amp; Immutability</div><div class="sec-sub">Why mutation silently breaks React ‚Äî and how to avoid it</div></div></div>
  <div class="topic-row"><span class="topic">Objects in Memory</span><span class="topic">Shallow Copy</span><span class="topic">Deep Copy</span><span class="topic">Spread Operator</span><span class="topic g">Rest Operator</span><span class="topic r">Mutating vs Non-Mutating</span><span class="topic r">Why Mutation Breaks React</span><span class="topic b">Updating Nested Objects</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">How do objects and arrays live in memory? Why is this the root cause of many bugs?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Objects and arrays are <strong>heap-allocated</strong>. When you create one, the engine stores the data on the heap and puts the <em>memory address</em> (a reference/pointer) into the variable ‚Äî not the data itself. This has three critical consequences:</p>
  <ul>
    <li><strong>Equality</strong> compares memory addresses, not content. Two objects with identical data are NOT equal unless they're the same object.</li>
    <li><strong>Assignment</strong> copies the address, not the data. Two variables pointing to the same address see the same object.</li>
    <li><strong>Mutation</strong> through any reference affects what all other references to that object see.</li>
  </ul>
  <pre><span class="cm">// Primitives: stored in the variable directly (stack)</span>
<span class="kw">let</span> a = <span class="num">42</span>;
<span class="kw">let</span> b = a;   <span class="cm">// b gets a copy of 42 ‚Äî completely independent</span>
b = <span class="num">100</span>;
console.<span class="fn">log</span>(a); <span class="cm">// 42 ‚Äî unaffected</span>

<span class="cm">// Objects: variable holds heap address, data lives on heap</span>
<span class="kw">let</span> user1 = { name: <span class="str">'Alice'</span>, score: <span class="num">100</span> };
<span class="cm">//   user1 variable ‚Üí [address: 0xF1A0]</span>
<span class="cm">//   heap @ 0xF1A0 ‚Üí { name: 'Alice', score: 100 }</span>

<span class="kw">let</span> user2 = user1;   <span class="cm">// user2 also ‚Üí [address: 0xF1A0]</span>
user2.name = <span class="str">'Bob'</span>; <span class="cm">// mutates the object AT 0xF1A0</span>
console.<span class="fn">log</span>(user1.name); <span class="cm">// 'Bob' ‚Äî user1 also points to 0xF1A0!</span>

<span class="cm">// Equality checks address (identity), not content</span>
<span class="kw">const</span> x = { val: <span class="num">1</span> };
<span class="kw">const</span> y = { val: <span class="num">1</span> }; <span class="cm">// same content, different heap allocation</span>
<span class="kw">const</span> z = x;          <span class="cm">// same address as x</span>
x === y; <span class="cm">// false ‚Äî different addresses</span>
x === z; <span class="cm">// true  ‚Äî same address</span>
JSON.<span class="fn">stringify</span>(x) === JSON.<span class="fn">stringify</span>(y); <span class="cm">// true ‚Äî content comparison</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is a shallow copy and what are its limitations?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>shallow copy</strong> creates a new top-level object/array, but copies only the immediate property values. If any of those values are themselves objects or arrays, <em>only the reference</em> is copied ‚Äî not the nested data. The original and copy therefore share their nested objects.</p>
  <pre><span class="kw">const</span> original = {
  name: <span class="str">'Alice'</span>,                              <span class="cm">// primitive ‚Äî copied by value</span>
  scores: [<span class="num">90</span>, <span class="num">85</span>, <span class="num">95</span>],                      <span class="cm">// nested ‚Äî only reference copied</span>
  address: { city: <span class="str">'NYC'</span>, zip: <span class="str">'10001'</span> }    <span class="cm">// nested ‚Äî only reference copied</span>
};

<span class="cm">// Three ways to shallow copy an object</span>
<span class="kw">const</span> copy1 = { ...original };                <span class="cm">// spread (preferred)</span>
<span class="kw">const</span> copy2 = Object.<span class="fn">assign</span>({}, original);  <span class="cm">// Object.assign</span>
<span class="kw">const</span> copy3 = Object.<span class="fn">fromEntries</span>(Object.<span class="fn">entries</span>(original)); <span class="cm">// fromEntries</span>

<span class="cm">// ‚úÖ Top-level is independent</span>
copy1.name = <span class="str">'Bob'</span>;
console.<span class="fn">log</span>(original.name);  <span class="cm">// 'Alice' ‚Äî unaffected ‚úÖ</span>

<span class="cm">// ‚ùå Nested objects/arrays are still shared</span>
copy1.address.city = <span class="str">'LA'</span>;
console.<span class="fn">log</span>(original.address.city); <span class="cm">// 'LA' ‚Äî MUTATED via shared reference!</span>

copy1.scores.<span class="fn">push</span>(<span class="num">100</span>);
console.<span class="fn">log</span>(original.scores); <span class="cm">// [90, 85, 95, 100] ‚Äî MUTATED!</span>

<span class="cm">// Shallow copying arrays</span>
<span class="kw">const</span> arr = [<span class="num">1</span>, [<span class="num">2</span>, <span class="num">3</span>], { a: <span class="num">4</span> }];
<span class="kw">const</span> arrCopy = [...arr];  <span class="cm">// shallow copy</span>
arrCopy[<span class="num">0</span>] = <span class="num">99</span>;          <span class="cm">// ‚úÖ primitive ‚Äî original[0] stays 1</span>
arrCopy[<span class="num">1</span>].<span class="fn">push</span>(<span class="num">4</span>);     <span class="cm">// ‚ùå nested array ‚Äî original[1] is [2,3,4]!</span></pre>
  <div class="callout warn"><div class="callout-title">‚ö†Ô∏è Common React Bug</div><p>Shallow copying an array of objects is one of the most common React mistakes. <code>[...users]</code> creates a new array, but the user objects inside are still shared. Mutating <code>users[0].name</code> affects both the original and the copy ‚Äî React won't detect this as a state change because the object reference is the same.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is a deep copy and what are your options for creating one?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>deep copy</strong> recursively duplicates every level ‚Äî no references are shared at any depth. Mutations to the copy never touch the original.</p>
  <pre><span class="kw">const</span> original = {
  name: <span class="str">'Alice'</span>,
  prefs: { theme: <span class="str">'dark'</span>, lang: <span class="str">'en'</span> },
  tags: [<span class="str">'admin'</span>, <span class="str">'user'</span>],
  joined: <span class="kw">new</span> Date(<span class="str">'2023-01-01'</span>),
  <span class="fn">greet</span>: () => <span class="str">'hi'</span>
};

<span class="cm">// ‚îÄ‚îÄ‚îÄ 1. structuredClone() ‚Äî BEST modern option ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> deep1 = structuredClone(original);
<span class="cm">// ‚úÖ Handles: nested objects, arrays, Dates, RegExp, Map, Set, circular refs</span>
<span class="cm">// ‚ùå Loses: functions, DOM nodes, class instances (methods stripped)</span>

deep1.prefs.theme = <span class="str">'light'</span>;
console.<span class="fn">log</span>(original.prefs.theme); <span class="cm">// 'dark' ‚úÖ unaffected</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ 2. JSON round-trip ‚Äî limited but widely used ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> deep2 = JSON.<span class="fn">parse</span>(JSON.<span class="fn">stringify</span>(original));
<span class="cm">// ‚ùå Loses: undefined, functions, Dates ‚Üí strings, Symbol, Map, Set</span>
<span class="cm">// ‚ùå Throws on circular references</span>
<span class="cm">// ‚úÖ Fine for: plain data with primitives, nested objects, arrays</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ 3. Manual recursive clone ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">function</span> <span class="fn">deepClone</span>(val) {
  <span class="kw">if</span> (val === <span class="kw">null</span> || <span class="kw">typeof</span> val !== <span class="str">'object'</span>) <span class="kw">return</span> val;
  <span class="kw">if</span> (val <span class="kw">instanceof</span> Date) <span class="kw">return</span> <span class="kw">new</span> Date(val);
  <span class="kw">if</span> (Array.<span class="fn">isArray</span>(val)) <span class="kw">return</span> val.<span class="fn">map</span>(<span class="fn">deepClone</span>);
  <span class="kw">return</span> Object.<span class="fn">fromEntries</span>(Object.<span class="fn">entries</span>(val).<span class="fn">map</span>(([k, v]) => [k, <span class="fn">deepClone</span>(v)]));
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ 4. lodash _.cloneDeep ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// import _ from 'lodash';</span>
<span class="cm">// const deep4 = _.cloneDeep(original);</span>
<span class="cm">// Most robust ‚Äî handles every edge case including circular refs</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">How does the spread operator work for objects and arrays?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The spread operator (<code>...</code>) expands an iterable into individual elements. For objects, it copies all own enumerable properties into the new object. Later properties overwrite earlier ones ‚Äî this makes it great for immutable updates.</p>
  <pre><span class="cm">// Object spread ‚Äî create new objects from existing ones</span>
<span class="kw">const</span> defaults = { theme: <span class="str">'light'</span>, lang: <span class="str">'en'</span>, fontSize: <span class="num">16</span> };
<span class="kw">const</span> userPrefs = { theme: <span class="str">'dark'</span>, fontSize: <span class="num">18</span> };

<span class="cm">// Merge: later props overwrite earlier ones</span>
<span class="kw">const</span> finalPrefs = { ...defaults, ...userPrefs };
<span class="cm">// { theme: 'dark', lang: 'en', fontSize: 18 }</span>

<span class="cm">// Immutable update: change one property</span>
<span class="kw">const</span> user = { id: <span class="num">1</span>, name: <span class="str">'Alice'</span>, age: <span class="num">30</span>, active: <span class="kw">true</span> };
<span class="kw">const</span> aged = { ...user, age: <span class="num">31</span> };  <span class="cm">// new obj, user unchanged</span>
<span class="cm">// { id: 1, name: 'Alice', age: 31, active: true }</span>

<span class="cm">// Override takes precedence based on position</span>
<span class="kw">const</span> a = { x: <span class="num">1</span>, y: <span class="num">2</span> };
<span class="kw">const</span> b1 = { ...a, x: <span class="num">99</span> };   <span class="cm">// { x: 99, y: 2 }  ‚Äî override wins</span>
<span class="kw">const</span> b2 = { x: <span class="num">99</span>, ...a };   <span class="cm">// { x: 1, y: 2 }   ‚Äî spread wins</span>

<span class="cm">// Remove a property (spread + destructuring)</span>
<span class="kw">const</span> { password, ...safeUser } = user;
<span class="cm">// safeUser = { id: 1, name: 'Alice', age: 30, active: true }</span>

<span class="cm">// Array spread</span>
<span class="kw">const</span> arr1 = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>];
<span class="kw">const</span> arr2 = [<span class="num">4</span>, <span class="num">5</span>, <span class="num">6</span>];
<span class="kw">const</span> combined = [...arr1, ...arr2];       <span class="cm">// [1,2,3,4,5,6]</span>
<span class="kw">const</span> withHead  = [<span class="num">0</span>, ...arr1];           <span class="cm">// [0,1,2,3]</span>
<span class="kw">const</span> withTail  = [...arr1, <span class="num">4</span>];           <span class="cm">// [1,2,3,4]</span>

<span class="cm">// Spread a string into characters</span>
[...<span class="str">'hello'</span>];  <span class="cm">// ['h', 'e', 'l', 'l', 'o']</span>

<span class="cm">// Spread into function args</span>
<span class="kw">const</span> nums = [<span class="num">5</span>, <span class="num">1</span>, <span class="num">9</span>, <span class="num">3</span>];
Math.<span class="fn">max</span>(...nums);  <span class="cm">// 9</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">Why does direct mutation break React state? Explain with code.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>React determines whether to re-render a component by comparing the previous and new state/props references. If you mutate an object directly, the reference (memory address) stays the same. React sees <code>oldState === newState</code> and concludes nothing changed ‚Äî even though the data inside changed. No re-render occurs.</p>
  <pre><span class="cm">// ‚ùå WRONG ‚Äî direct mutation, React won't re-render</span>
<span class="kw">const</span> [user, setUser] = <span class="fn">useState</span>({ name: <span class="str">'Alice'</span>, age: <span class="num">25</span> });

<span class="kw">const</span> <span class="fn">birthday</span> = () => {
  user.age++;       <span class="cm">// mutates the SAME object</span>
  <span class="fn">setUser</span>(user);   <span class="cm">// React: old ref === new ref ‚Üí skip re-render!</span>
};

<span class="cm">// ‚úÖ CORRECT ‚Äî create a new object</span>
<span class="kw">const</span> <span class="fn">birthday</span> = () => {
  <span class="fn">setUser</span>({ ...user, age: user.age + <span class="num">1</span> });  <span class="cm">// new reference ‚Üí re-render</span>
};

<span class="cm">// ‚ùå WRONG ‚Äî mutating nested object</span>
<span class="kw">const</span> [profile, setProfile] = <span class="fn">useState</span>({
  user: { name: <span class="str">'Alice'</span> },
  settings: { theme: <span class="str">'dark'</span> }
});
<span class="kw">const</span> <span class="fn">updateTheme</span> = (t) => {
  profile.settings.theme = t;    <span class="cm">// mutation!</span>
  <span class="fn">setProfile</span>(profile);           <span class="cm">// same outer reference ‚Üí no re-render</span>
};

<span class="cm">// ‚úÖ CORRECT ‚Äî new objects at every level of the change</span>
<span class="kw">const</span> <span class="fn">updateTheme</span> = (t) => {
  <span class="fn">setProfile</span>({
    ...profile,
    settings: { ...profile.settings, theme: t }
  });
};

<span class="cm">// ‚ùå WRONG ‚Äî mutating array in state</span>
<span class="kw">const</span> [items, setItems] = <span class="fn">useState</span>([<span class="str">'a'</span>, <span class="str">'b'</span>]);
<span class="kw">const</span> <span class="fn">addItem</span> = (item) => {
  items.<span class="fn">push</span>(item);    <span class="cm">// mutation ‚Äî same reference</span>
  <span class="fn">setItems</span>(items);     <span class="cm">// no re-render!</span>
};

<span class="cm">// ‚úÖ CORRECT ‚Äî spread creates new array</span>
<span class="kw">const</span> <span class="fn">addItem</span> = (item) => <span class="fn">setItems</span>([...items, item]);</pre>
  <div class="callout info"><div class="callout-title">‚ÑπÔ∏è Key Insight</div><p>React's re-render detection uses <em>shallow equality</em> (<code>===</code>) for state comparison. A new object with a new reference triggers a re-render; the same mutated object does not. This is why immutable updates ‚Äî always creating new objects instead of modifying existing ones ‚Äî are fundamental to React's design.</p></div></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.06</span><span class="qa-text">Show the correct immutable patterns for common update operations in arrays of objects.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>These are the patterns you'll use constantly in React state management. Each creates a new array and new objects without mutating anything.</p>
  <pre><span class="kw">const</span> users = [
  { id: <span class="num">1</span>, name: <span class="str">'Alice'</span>, active: <span class="kw">true</span> },
  { id: <span class="num">2</span>, name: <span class="str">'Bob'</span>,   active: <span class="kw">false</span> },
  { id: <span class="num">3</span>, name: <span class="str">'Carol'</span>, active: <span class="kw">true</span> },
];

<span class="cm">// ‚îÄ‚îÄ‚îÄ ADD an item ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> withNew = [...users, { id: <span class="num">4</span>, name: <span class="str">'Dave'</span>, active: <span class="kw">true</span> }];

<span class="cm">// ‚îÄ‚îÄ‚îÄ REMOVE an item by id ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> withoutBob = users.<span class="fn">filter</span>(u => u.id !== <span class="num">2</span>);

<span class="cm">// ‚îÄ‚îÄ‚îÄ UPDATE one item's property ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> withAliceDeactivated = users.<span class="fn">map</span>(u =>
  u.id === <span class="num">1</span> ? { ...u, active: <span class="kw">false</span> } : u
);
<span class="cm">// Only Alice's object is new, Bob and Carol are the same references</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ UPDATE a nested property ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> profile = {
  user: { id: <span class="num">1</span>, name: <span class="str">'Alice'</span> },
  settings: { theme: <span class="str">'dark'</span>, notifications: { email: <span class="kw">true</span>, sms: <span class="kw">false</span> } }
};

<span class="cm">// Update nested notification.email</span>
<span class="kw">const</span> updated = {
  ...profile,
  settings: {
    ...profile.settings,
    notifications: {
      ...profile.settings.notifications,
      email: <span class="kw">false</span>
    }
  }
};
<span class="cm">// profile is unchanged, 'updated' is a new object all the way down</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ TOGGLE a property ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> toggled = users.<span class="fn">map</span>(u =>
  u.id === <span class="num">2</span> ? { ...u, active: !u.active } : u
);</pre></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s4')">‚Üê Scope &amp; Closures</button><button class="btn primary" onclick="go('s6')">Array Methods ‚Üí</button></div>
</div>
<!-- S6: ARRAY METHODS -->
<div class="section" id="sec-s6">
  <div class="section-head"><div class="sec-num">06</div><div><div class="sec-title">Array Methods &amp; Functional JS</div><div class="sec-sub">Transform, filter, and reduce data without mutation</div></div></div>
  <div class="topic-row"><span class="topic">Higher-Order Functions</span><span class="topic">map()</span><span class="topic">filter()</span><span class="topic">reduce()</span><span class="topic g">Chaining</span><span class="topic b">find / some / every</span><span class="topic r">forEach vs map</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What is a higher-order function? Why are array methods designed this way?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>higher-order function</strong> is a function that either takes a function as an argument, returns a function, or both. Array methods like <code>map</code>, <code>filter</code>, and <code>reduce</code> are all higher-order functions ‚Äî they take a callback function as an argument and apply it to each element.</p>
  <p>This design separates <em>the iteration mechanism</em> (looping) from <em>the transformation logic</em> (what to do each step). The array method handles the loop; you provide the logic. This is cleaner, composable, and less error-prone than manual for-loops.</p>
  <pre><span class="cm">// HOF: takes a function as argument</span>
<span class="kw">function</span> <span class="fn">applyTwice</span>(fn, value) {
  <span class="kw">return</span> <span class="fn">fn</span>(<span class="fn">fn</span>(value));
}
<span class="fn">applyTwice</span>(x => x * <span class="num">2</span>, <span class="num">3</span>); <span class="cm">// 12 (doubles twice)</span>

<span class="cm">// Array methods are HOFs ‚Äî callback defines the logic</span>
<span class="kw">const</span> nums = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">4</span>, <span class="num">5</span>];

<span class="cm">// Same loop, different transformations ‚Äî compose the logic</span>
nums.<span class="fn">map</span>(n => n * <span class="num">2</span>);       <span class="cm">// [2, 4, 6, 8, 10]</span>
nums.<span class="fn">map</span>(n => n ** <span class="num">2</span>);       <span class="cm">// [1, 4, 9, 16, 25]</span>
nums.<span class="fn">map</span>(n => n.<span class="fn">toString</span>()); <span class="cm">// ['1','2','3','4','5']</span>

<span class="cm">// vs imperative style ‚Äî repeated boilerplate</span>
<span class="kw">const</span> doubled = [];
<span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i &lt; nums.length; i++) {
  doubled.<span class="fn">push</span>(nums[i] * <span class="num">2</span>);
}</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">Explain map() in depth ‚Äî what does it return, what is the callback signature?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><code>map()</code> creates a <strong>new array</strong> of the same length as the original, where each element is the result of calling the callback on the corresponding original element. It never modifies the original array. If the callback returns nothing (undefined), the new array has undefined at that index.</p>
  <h4>Callback Signature: <code>(currentValue, index, array) => newValue</code></h4>
  <pre><span class="kw">const</span> products = [
  { id: <span class="num">1</span>, name: <span class="str">'Laptop'</span>, price: <span class="num">999</span>, inStock: <span class="kw">true</span> },
  { id: <span class="num">2</span>, name: <span class="str">'Mouse'</span>,  price: <span class="num">29</span>,  inStock: <span class="kw">false</span> },
  { id: <span class="num">3</span>, name: <span class="str">'Monitor'</span>,price: <span class="num">349</span>, inStock: <span class="kw">true</span> },
];

<span class="cm">// Extract a single property</span>
<span class="kw">const</span> names = products.<span class="fn">map</span>(p => p.name);
<span class="cm">// ['Laptop', 'Mouse', 'Monitor']</span>

<span class="cm">// Transform and reshape</span>
<span class="kw">const</span> withTax = products.<span class="fn">map</span>(p => ({
  ...p,
  priceWithTax: (p.price * <span class="num">1.1</span>).<span class="fn">toFixed</span>(<span class="num">2</span>)
}));

<span class="cm">// Using index parameter</span>
<span class="kw">const</span> withRank = products.<span class="fn">map</span>((p, i) => ({ ...p, rank: i + <span class="num">1</span> }));

<span class="cm">// Map does NOT mutate ‚Äî original products is unchanged</span>
console.<span class="fn">log</span>(products[<span class="num">0</span>].priceWithTax); <span class="cm">// undefined</span>

<span class="cm">// Common mistake: forgetting the return</span>
<span class="kw">const</span> broken = products.<span class="fn">map</span>(p => {
  p.price * <span class="num">1.1</span>;  <span class="cm">// ‚Üê no return! each element becomes undefined</span>
});
<span class="cm">// broken = [undefined, undefined, undefined]</span>

<span class="cm">// Fix: either implicit return or explicit return</span>
<span class="kw">const</span> fixed = products.<span class="fn">map</span>(p => p.price * <span class="num">1.1</span>); <span class="cm">// implicit</span>
<span class="kw">const</span> fixed2 = products.<span class="fn">map</span>(p => { <span class="kw">return</span> p.price * <span class="num">1.1</span>; }); <span class="cm">// explicit</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">Explain filter() ‚Äî what does it return, what determines inclusion?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><code>filter()</code> creates a <strong>new array</strong> containing only the elements for which the callback returns a <em>truthy</em> value. The resulting array can be shorter than the original (or empty, or the same length). Elements are never modified ‚Äî they're either included or excluded by reference.</p>
  <h4>Callback Signature: <code>(currentValue, index, array) => boolean</code></h4>
  <pre><span class="kw">const</span> users = [
  { id: <span class="num">1</span>, name: <span class="str">'Alice'</span>, age: <span class="num">28</span>, role: <span class="str">'admin'</span>, active: <span class="kw">true</span> },
  { id: <span class="num">2</span>, name: <span class="str">'Bob'</span>,   age: <span class="num">17</span>, role: <span class="str">'user'</span>,  active: <span class="kw">true</span> },
  { id: <span class="num">3</span>, name: <span class="str">'Carol'</span>, age: <span class="num">35</span>, role: <span class="str">'admin'</span>, active: <span class="kw">false</span> },
  { id: <span class="num">4</span>, name: <span class="str">'Dave'</span>,  age: <span class="num">22</span>, role: <span class="str">'user'</span>,  active: <span class="kw">true</span> },
];

<span class="cm">// Simple filter</span>
<span class="kw">const</span> adults     = users.<span class="fn">filter</span>(u => u.age >= <span class="num">18</span>);
<span class="kw">const</span> admins     = users.<span class="fn">filter</span>(u => u.role === <span class="str">'admin'</span>);
<span class="kw">const</span> activeAdmins = users.<span class="fn">filter</span>(u => u.active && u.role === <span class="str">'admin'</span>);

<span class="cm">// Remove falsy values</span>
[<span class="num">1</span>, <span class="num">0</span>, <span class="str">''</span>, <span class="num">2</span>, <span class="kw">null</span>, <span class="num">3</span>, <span class="kw">undefined</span>].<span class="fn">filter</span>(Boolean); <span class="cm">// [1, 2, 3]</span>

<span class="cm">// Remove duplicates</span>
<span class="kw">const</span> arr = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="num">3</span>, <span class="num">3</span>];
arr.<span class="fn">filter</span>((val, idx) => arr.<span class="fn">indexOf</span>(val) === idx); <span class="cm">// [1, 2, 3]</span>
[...new Set(arr)]; <span class="cm">// [1, 2, 3] ‚Äî simpler for duplicates</span>

<span class="cm">// Search/filter by text (common in UIs)</span>
<span class="kw">const</span> <span class="fn">searchUsers</span> = (query) =>
  users.<span class="fn">filter</span>(u => u.name.<span class="fn">toLowerCase</span>().<span class="fn">includes</span>(query.<span class="fn">toLowerCase</span>()));</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">Explain reduce() in depth ‚Äî the accumulator pattern and common use cases.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><code>reduce()</code> is the most powerful ‚Äî and most misunderstood ‚Äî array method. It processes each element and accumulates a single result. The accumulator is passed from iteration to iteration, building up the final value. The return value can be any type ‚Äî a number, string, object, or even an array.</p>
  <h4>Signature: <code>array.reduce((accumulator, currentValue, index, array) => newAccumulator, initialValue)</code></h4>
  <div class="callout danger"><div class="callout-title">üö® Always provide initialValue</div><p>Without it, reduce uses the first element as the accumulator and starts iteration from index 1. On an empty array, it throws a TypeError. Always provide the initial value to make the behavior explicit and safe.</p></div>
  <pre><span class="kw">const</span> orders = [
  { product: <span class="str">'Laptop'</span>, qty: <span class="num">1</span>, price: <span class="num">999</span>, category: <span class="str">'electronics'</span> },
  { product: <span class="str">'Mouse'</span>,  qty: <span class="num">2</span>, price: <span class="num">29</span>,  category: <span class="str">'electronics'</span> },
  { product: <span class="str">'Desk'</span>,   qty: <span class="num">1</span>, price: <span class="num">349</span>, category: <span class="str">'furniture'</span> },
  { product: <span class="str">'Chair'</span>,  qty: <span class="num">2</span>, price: <span class="num">199</span>, category: <span class="str">'furniture'</span> },
];

<span class="cm">// Sum: reduce to a number</span>
<span class="kw">const</span> total = orders.<span class="fn">reduce</span>((sum, order) =>
  sum + order.price * order.qty, <span class="num">0</span>
); <span class="cm">// 999 + 58 + 349 + 398 = 1804</span>

<span class="cm">// Group by category: reduce to an object</span>
<span class="kw">const</span> byCategory = orders.<span class="fn">reduce</span>((acc, order) => {
  <span class="kw">const</span> cat = order.category;
  <span class="kw">if</span> (!acc[cat]) acc[cat] = [];
  acc[cat].<span class="fn">push</span>(order.product);
  <span class="kw">return</span> acc;
}, {});
<span class="cm">// { electronics: ['Laptop', 'Mouse'], furniture: ['Desk', 'Chair'] }</span>

<span class="cm">// Build a lookup map: reduce to Map</span>
<span class="kw">const</span> productMap = orders.<span class="fn">reduce</span>((map, order) => {
  map.<span class="fn">set</span>(order.product, order.price);
  <span class="kw">return</span> map;
}, <span class="kw">new</span> Map());
productMap.<span class="fn">get</span>(<span class="str">'Laptop'</span>); <span class="cm">// 999</span>

<span class="cm">// Flatten array of arrays</span>
[[<span class="num">1</span>,<span class="num">2</span>], [<span class="num">3</span>,<span class="num">4</span>], [<span class="num">5</span>]].<span class="fn">reduce</span>((flat, arr) => [...flat, ...arr], []);
<span class="cm">// [1,2,3,4,5] ‚Äî equivalent to .flat()</span>

<span class="cm">// Pipeline of transformations using reduce</span>
<span class="kw">const</span> pipeline = [
  x => x * <span class="num">2</span>,
  x => x + <span class="num">10</span>,
  x => x.<span class="fn">toString</span>()
];
pipeline.<span class="fn">reduce</span>((val, fn) => <span class="fn">fn</span>(val), <span class="num">5</span>); <span class="cm">// '20'  (5*2=10, 10+10=20, '20')</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">How do you chain array methods? What are the performance considerations?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>Array methods return new arrays, so you can chain them. Each method in the chain iterates through the entire array. For performance-sensitive code with large datasets, combining steps into a single <code>reduce()</code> can be faster than chaining multiple passes.</p>
  <pre><span class="kw">const</span> employees = [
  { name: <span class="str">'Alice'</span>, dept: <span class="str">'Engineering'</span>, salary: <span class="num">95000</span>, yrs: <span class="num">5</span> },
  { name: <span class="str">'Bob'</span>,   dept: <span class="str">'Marketing'</span>,   salary: <span class="num">70000</span>, yrs: <span class="num">2</span> },
  { name: <span class="str">'Carol'</span>, dept: <span class="str">'Engineering'</span>, salary: <span class="num">105000</span>,yrs: <span class="num">8</span> },
  { name: <span class="str">'Dave'</span>,  dept: <span class="str">'Engineering'</span>, salary: <span class="num">88000</span>, yrs: <span class="num">3</span> },
];

<span class="cm">// Chain: filter ‚Üí map ‚Üí sort ‚Üí slice</span>
<span class="kw">const</span> topEngineers = employees
  .<span class="fn">filter</span>(e => e.dept === <span class="str">'Engineering'</span>)      <span class="cm">// pass #1: 3 elements</span>
  .<span class="fn">filter</span>(e => e.yrs >= <span class="num">4</span>)                    <span class="cm">// pass #2: 2 elements</span>
  .<span class="fn">map</span>(e => ({ name: e.name, salary: e.salary })) <span class="cm">// pass #3: reshape</span>
  .<span class="fn">sort</span>((a, b) => b.salary - a.salary)          <span class="cm">// pass #4: sort desc</span>
  .<span class="fn">slice</span>(<span class="num">0</span>, <span class="num">2</span>);                               <span class="cm">// top 2</span>

<span class="cm">// [{ name: 'Carol', salary: 105000 }, { name: 'Alice', salary: 95000 }]</span>

<span class="cm">// Performance: combine into single reduce for large arrays</span>
<span class="kw">const</span> result = employees.<span class="fn">reduce</span>((acc, e) => {
  <span class="kw">if</span> (e.dept === <span class="str">'Engineering'</span> && e.yrs >= <span class="num">4</span>) {
    acc.<span class="fn">push</span>({ name: e.name, salary: e.salary });
  }
  <span class="kw">return</span> acc;
}, []).<span class="fn">sort</span>((a, b) => b.salary - a.salary).<span class="fn">slice</span>(<span class="num">0</span>, <span class="num">2</span>);
<span class="cm">// One pass instead of two filter passes + one map pass</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.06</span><span class="qa-text">What is the difference between forEach and map? When should you use each?</span><span class="qa-tog">+</span></div>
  <div class="qa-a">
  <table>
    <tr><th>Feature</th><th>forEach</th><th>map</th></tr>
    <tr><td>Return value</td><td>undefined always</td><td>New array of return values</td></tr>
    <tr><td>Use when</td><td>Side effects (logging, DOM updates)</td><td>Transforming data</td></tr>
    <tr><td>Chainable</td><td>No (returns undefined)</td><td>Yes (returns array)</td></tr>
    <tr><td>Idiomatic</td><td>Imperative style</td><td>Functional style</td></tr>
  </table>
  <pre><span class="cm">// forEach ‚Äî for side effects, no return value needed</span>
[<span class="str">'Alice'</span>, <span class="str">'Bob'</span>].<span class="fn">forEach</span>(name => {
  console.<span class="fn">log</span>(<span class="str">`Processing ${name}`</span>);  <span class="cm">// side effect</span>
  saveToDatabase(name);                  <span class="cm">// side effect</span>
});

<span class="cm">// map ‚Äî for transformation, creates a new array</span>
<span class="kw">const</span> upper = [<span class="str">'Alice'</span>, <span class="str">'Bob'</span>].<span class="fn">map</span>(name => name.<span class="fn">toUpperCase</span>());
<span class="cm">// ['ALICE', 'BOB']</span>

<span class="cm">// forEach ignores the return value</span>
<span class="kw">const</span> result = [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="fn">forEach</span>(n => n * <span class="num">2</span>);
console.<span class="fn">log</span>(result); <span class="cm">// undefined ‚Äî forEach ALWAYS returns undefined</span>

<span class="cm">// Can't chain forEach</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]
  .<span class="fn">forEach</span>(n => n * <span class="num">2</span>)  <span class="cm">// returns undefined</span>
  .<span class="fn">filter</span>(...);           <span class="cm">// ‚ùå TypeError: undefined.filter is not a function</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.07</span><span class="qa-text">Explain find(), some(), every(), and flat() ‚Äî when do you use each?</span><span class="qa-tog">+</span></div>
  <div class="qa-a">
  <pre><span class="kw">const</span> users = [
  { id: <span class="num">1</span>, name: <span class="str">'Alice'</span>, age: <span class="num">28</span>, verified: <span class="kw">true</span> },
  { id: <span class="num">2</span>, name: <span class="str">'Bob'</span>,   age: <span class="num">17</span>, verified: <span class="kw">false</span> },
  { id: <span class="num">3</span>, name: <span class="str">'Carol'</span>, age: <span class="num">35</span>, verified: <span class="kw">true</span> },
];

<span class="cm">// find() ‚Äî returns the FIRST matching element (or undefined)</span>
<span class="kw">const</span> alice = users.<span class="fn">find</span>(u => u.name === <span class="str">'Alice'</span>);
<span class="cm">// { id: 1, name: 'Alice', age: 28, verified: true }</span>
users.<span class="fn">find</span>(u => u.age > <span class="num">100</span>); <span class="cm">// undefined ‚Äî no match</span>

<span class="cm">// findIndex() ‚Äî returns index of first match (or -1)</span>
users.<span class="fn">findIndex</span>(u => u.id === <span class="num">3</span>); <span class="cm">// 2</span>

<span class="cm">// some() ‚Äî returns true if ANY element passes the test</span>
users.<span class="fn">some</span>(u => !u.verified);  <span class="cm">// true ‚Äî Bob is unverified</span>
users.<span class="fn">some</span>(u => u.age > <span class="num">100</span>); <span class="cm">// false ‚Äî nobody is >100</span>

<span class="cm">// every() ‚Äî returns true if ALL elements pass the test</span>
users.<span class="fn">every</span>(u => u.verified);   <span class="cm">// false ‚Äî Bob is not</span>
users.<span class="fn">every</span>(u => u.age > <span class="num">0</span>);   <span class="cm">// true ‚Äî all ages are positive</span>

<span class="cm">// includes() ‚Äî for simple value check</span>
[<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>].<span class="fn">includes</span>(<span class="num">2</span>);  <span class="cm">// true</span>

<span class="cm">// flat() ‚Äî flatten nested arrays</span>
[<span class="num">1</span>, [<span class="num">2</span>, <span class="num">3</span>], [<span class="num">4</span>, [<span class="num">5</span>]]].<span class="fn">flat</span>();    <span class="cm">// [1, 2, 3, 4, [5]] ‚Äî one level</span>
[<span class="num">1</span>, [<span class="num">2</span>, [<span class="num">3</span>]]].<span class="fn">flat</span>(<span class="num">2</span>);           <span class="cm">// [1, 2, 3] ‚Äî two levels</span>
[<span class="num">1</span>, [<span class="num">2</span>, [<span class="num">3</span>, [<span class="num">4</span>]]]].<span class="fn">flat</span>(Infinity); <span class="cm">// [1, 2, 3, 4] ‚Äî all levels</span>

<span class="cm">// flatMap() ‚Äî map then flat (1 level) ‚Äî common for 1:many transforms</span>
<span class="kw">const</span> sentences = [<span class="str">'hello world'</span>, <span class="str">'foo bar'</span>];
sentences.<span class="fn">flatMap</span>(s => s.<span class="fn">split</span>(<span class="str">' '</span>));
<span class="cm">// ['hello', 'world', 'foo', 'bar']</span></pre></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s5')">‚Üê Objects</button><button class="btn primary" onclick="go('s7')">Async JavaScript ‚Üí</button></div>
</div>
<!-- S7: ASYNC JS -->
<div class="section" id="sec-s7">
  <div class="section-head"><div class="sec-num">07</div><div><div class="sec-title">Asynchronous JavaScript</div><div class="sec-sub">Why JS is non-blocking and how callbacks and promises work</div></div></div>
  <div class="topic-row"><span class="topic">Sync vs Async</span><span class="topic">Why Async Exists</span><span class="topic">Callbacks</span><span class="topic r">Callback Hell</span><span class="topic g">Promises</span><span class="topic g">Promise States</span><span class="topic">then/catch/finally</span><span class="topic b">Error Propagation</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What is the difference between synchronous and asynchronous JavaScript? Why does async exist?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><strong>Synchronous</strong> code executes line by line, in order. Each operation must complete before the next one begins. <strong>Asynchronous</strong> code initiates an operation and moves on without waiting for it to finish. When the operation completes, a callback or promise resolution handles the result.</p>
  <p>JavaScript is <strong>single-threaded</strong> ‚Äî it has one call stack and can only do one thing at a time. If synchronous operations that take time (network requests, file reads, timers) were allowed to block the thread, the entire UI would freeze while waiting. Async patterns delegate time-consuming work to browser APIs or the OS, keeping the main thread free to respond to user input.</p>
  <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Synchronous: each line blocks the next ‚îÄ‚îÄ‚îÄ</span>
console.<span class="fn">log</span>(<span class="str">'1: Start'</span>);
<span class="kw">const</span> result = <span class="fn">expensiveSync</span>(); <span class="cm">// blocks for 3 seconds ‚Äî UI freezes!</span>
console.<span class="fn">log</span>(<span class="str">'2: Result:', result</span>); <span class="cm">// only after expensiveSync completes</span>
console.<span class="fn">log</span>(<span class="str">'3: Done'</span>);

<span class="cm">// ‚îÄ‚îÄ‚îÄ Asynchronous: initiate and continue ‚îÄ‚îÄ‚îÄ</span>
console.<span class="fn">log</span>(<span class="str">'1: Start'</span>);
<span class="fn">fetch</span>(<span class="str">'/api/data'</span>)           <span class="cm">// initiated ‚Äî browser handles this</span>
  .<span class="fn">then</span>(data => console.<span class="fn">log</span>(<span class="str">'3: Got data'</span>, data)); <span class="cm">// runs LATER</span>
console.<span class="fn">log</span>(<span class="str">'2: Moving on'</span>); <span class="cm">// runs BEFORE fetch completes</span>

<span class="cm">// Output: '1: Start', '2: Moving on', '3: Got data'</span>
<span class="cm">// The browser handles the HTTP request while JS continues executing</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What are callbacks? What is callback hell and why is it problematic?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>callback</strong> is a function passed as an argument to another function, to be invoked later when an async operation completes. It's the most basic async pattern in JS. Callbacks work, but when multiple async operations depend on each other, they nest deeply ‚Äî this is <strong>callback hell</strong> (also called the "pyramid of doom").</p>
  <p>Callback hell problems: (1) deep nesting makes code hard to read and reason about, (2) error handling is duplicated at each level, (3) the control flow is fragmented and hard to follow, (4) it's difficult to run operations in parallel.</p>
  <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Callback: basic pattern ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">function</span> <span class="fn">fetchUser</span>(id, callback) {
  setTimeout(() => {
    <span class="kw">if</span> (!id) callback(<span class="kw">new</span> Error(<span class="str">'No ID'</span>), <span class="kw">null</span>);
    <span class="kw">else</span> callback(<span class="kw">null</span>, { id, name: <span class="str">'Alice'</span> });  <span class="cm">// error-first convention</span>
  }, <span class="num">1000</span>);
}

<span class="fn">fetchUser</span>(<span class="num">1</span>, (err, user) => {
  <span class="kw">if</span> (err) <span class="kw">return</span> console.<span class="fn">error</span>(err);
  console.<span class="fn">log</span>(user);
});

<span class="cm">// ‚îÄ‚îÄ‚îÄ Callback hell: sequential async ops ‚îÄ‚îÄ‚îÄ</span>
<span class="fn">getUser</span>(userId, (err, user) => {
  <span class="kw">if</span> (err) handleError(err);        <span class="cm">// repeated error handling</span>
  <span class="kw">else</span> <span class="fn">getOrders</span>(user.id, (err, orders) => {
    <span class="kw">if</span> (err) handleError(err);      <span class="cm">// again!</span>
    <span class="kw">else</span> <span class="fn">getDetails</span>(orders[<span class="num">0</span>], (err, details) => {
      <span class="kw">if</span> (err) handleError(err);    <span class="cm">// again!</span>
      <span class="kw">else</span> <span class="fn">updateUI</span>(user, orders, details, (err) => {
        <span class="kw">if</span> (err) handleError(err);  <span class="cm">// pyramid of doom</span>
        <span class="kw">else</span> console.<span class="fn">log</span>(<span class="str">'Done!'</span>);
      });
    });
  });
});</pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is a Promise? Explain why it was invented and its three states.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>A <strong>Promise</strong> is an object representing the eventual completion (or failure) of an asynchronous operation. It was introduced to solve callback hell by providing a standard, chainable interface for async code. Instead of nesting callbacks, you <em>chain</em> <code>.then()</code> calls in a flat, readable sequence.</p>
  <h4>Three States (mutually exclusive, one-way transitions)</h4>
  <ul>
    <li><strong>Pending</strong> ‚Äî initial state, operation still in progress</li>
    <li><strong>Fulfilled</strong> ‚Äî operation completed successfully, has a value</li>
    <li><strong>Rejected</strong> ‚Äî operation failed, has a reason (error)</li>
  </ul>
  <p>Once a promise transitions from pending to settled (fulfilled or rejected), it <em>cannot change again</em>. A settled promise's value is permanently fixed.</p>
  <pre><span class="cm">// Creating a Promise</span>
<span class="kw">const</span> p = <span class="kw">new</span> Promise((resolve, reject) => {
  <span class="cm">// Executor runs synchronously ‚Äî work starts immediately</span>
  <span class="kw">const</span> success = <span class="kw">true</span>;
  <span class="kw">if</span> (success) {
    resolve(<span class="str">'All done!'</span>);    <span class="cm">// ‚Üí Fulfilled with 'All done!'</span>
  } <span class="kw">else</span> {
    reject(<span class="kw">new</span> Error(<span class="str">'Oops'</span>)); <span class="cm">// ‚Üí Rejected with Error</span>
  }
});

<span class="cm">// Promise wrapping setTimeout (classic)</span>
<span class="kw">function</span> <span class="fn">delay</span>(ms) {
  <span class="kw">return</span> <span class="kw">new</span> Promise(resolve => setTimeout(resolve, ms));
}
<span class="fn">delay</span>(<span class="num">1000</span>).<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">'1 second later!'</span>));

<span class="cm">// Promisifying a callback-based API</span>
<span class="kw">function</span> <span class="fn">readFilePromise</span>(path) {
  <span class="kw">return</span> <span class="kw">new</span> Promise((resolve, reject) => {
    fs.<span class="fn">readFile</span>(path, <span class="str">'utf8'</span>, (err, data) => {
      <span class="kw">if</span> (err) reject(err);
      <span class="kw">else</span> resolve(data);
    });
  });
}

<span class="cm">// States are permanent once settled</span>
<span class="kw">const</span> settled = Promise.<span class="fn">resolve</span>(<span class="num">42</span>);
<span class="cm">// This promise is ALWAYS fulfilled with 42 ‚Äî can never reject now</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">How do then(), catch(), and finally() work? Explain chaining and error propagation.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p><code>.then(onFulfilled, onRejected)</code> registers handlers. It always returns a <em>new promise</em>, which is what makes chaining work. The value returned from a <code>.then()</code> handler becomes the fulfillment value of the next promise in the chain. Errors automatically skip fulfilled handlers and flow to the next rejection handler.</p>
  <pre><span class="cm">// Basic then/catch/finally</span>
<span class="fn">fetch</span>(<span class="str">'/api/user'</span>)
  .<span class="fn">then</span>(response => response.<span class="fn">json</span>())    <span class="cm">// returns a new promise</span>
  .<span class="fn">then</span>(user => {
    console.<span class="fn">log</span>(user.name);
    <span class="kw">return</span> user.id;                    <span class="cm">// passed to next .then()</span>
  })
  .<span class="fn">then</span>(id => <span class="fn">fetch</span>(<span class="str">`/api/posts/${id}`</span>)) <span class="cm">// flat chain, no nesting!</span>
  .<span class="fn">then</span>(res => res.<span class="fn">json</span>())
  .<span class="fn">then</span>(posts => console.<span class="fn">log</span>(posts))
  .<span class="fn">catch</span>(err => console.<span class="fn">error</span>(<span class="str">'Error:'</span>, err))  <span class="cm">// catches ANY error above</span>
  .<span class="fn">finally</span>(() => <span class="fn">hideSpinner</span>());              <span class="cm">// always runs</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ Error propagation ‚Äî errors skip .then() handlers ‚îÄ‚îÄ‚îÄ</span>
Promise.<span class="fn">resolve</span>(<span class="str">'start'</span>)
  .<span class="fn">then</span>(v => { <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="str">'Step 2 failed'</span>); })
  .<span class="fn">then</span>(v => console.<span class="fn">log</span>(<span class="str">'Step 3'</span>, v))  <span class="cm">// SKIPPED ‚Äî error propagating</span>
  .<span class="fn">then</span>(v => console.<span class="fn">log</span>(<span class="str">'Step 4'</span>, v))  <span class="cm">// SKIPPED</span>
  .<span class="fn">catch</span>(err => {
    console.<span class="fn">log</span>(<span class="str">'Caught:'</span>, err.message); <span class="cm">// 'Step 2 failed'</span>
    <span class="kw">return</span> <span class="str">'recovered'</span>;                  <span class="cm">// error handled ‚Äî resumes chain</span>
  })
  .<span class="fn">then</span>(v => console.<span class="fn">log</span>(<span class="str">'Step 5'</span>, v));  <span class="cm">// 'Step 5 recovered' ‚Äî runs again</span>

<span class="cm">// finally ‚Äî always runs, doesn't change the value</span>
<span class="fn">fetch</span>(<span class="str">'/data'</span>)
  .<span class="fn">then</span>(processData)
  .<span class="fn">catch</span>(handleError)
  .<span class="fn">finally</span>(() => {
    <span class="cm">// Cleanup ‚Äî runs whether success or failure</span>
    <span class="fn">setLoading</span>(<span class="kw">false</span>);
    <span class="fn">stopSpinner</span>();
  });
<span class="cm">// The value passing through the chain is unaffected by finally()</span></pre></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s6')">‚Üê Array Methods</button><button class="btn primary" onclick="go('s8')">Event Loop ‚Üí</button></div>
</div>

<!-- S8: EVENT LOOP -->
<div class="section" id="sec-s8">
  <div class="section-head"><div class="sec-num">08</div><div><div class="sec-title">The Event Loop</div><div class="sec-sub">How JavaScript stays non-blocking with a single thread</div></div></div>
  <div class="topic-row"><span class="topic">Call Stack</span><span class="topic">Web APIs</span><span class="topic">Callback/Macrotask Queue</span><span class="topic g">Microtask Queue</span><span class="topic r">Execution Order</span><span class="topic b">Output Prediction</span></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">Explain the Event Loop architecture. What are all the moving parts?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The event loop is the mechanism that allows JavaScript ‚Äî a single-threaded language ‚Äî to handle asynchronous operations without blocking. It coordinates four components:</p>
  <h4>1. Call Stack</h4>
  <p>Where synchronous code executes. The engine processes whatever is on top. Only one frame at a time.</p>
  <h4>2. Web APIs / Node APIs</h4>
  <p>Browser (or Node) provides APIs like <code>setTimeout</code>, <code>fetch</code>, DOM events, <code>setInterval</code>. These run <em>outside</em> the call stack ‚Äî they're handled by the runtime, not JavaScript itself. When they complete, they push callbacks into a queue.</p>
  <h4>3. Macrotask Queue (Task Queue / Callback Queue)</h4>
  <p>Callbacks from <code>setTimeout</code>, <code>setInterval</code>, DOM events, <code>MessageChannel</code> go here. Processed one at a time, one per event loop iteration.</p>
  <h4>4. Microtask Queue</h4>
  <p>Promise callbacks (<code>.then</code>, <code>.catch</code>, <code>.finally</code>), <code>queueMicrotask()</code>, and <code>MutationObserver</code> callbacks go here. <strong>Critical rule:</strong> the microtask queue is <em>completely drained</em> after every task (including the initial script) before the next macrotask runs.</p>
  <h4>The Event Loop Rule</h4>
  <p>Run a macrotask ‚Üí drain all microtasks ‚Üí run next macrotask ‚Üí drain all microtasks ‚Üí repeat.</p>
  <pre><span class="cm">// Event Loop Architecture</span>
<span class="cm">// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="cm">// ‚îÇ             Call Stack                   ‚îÇ ‚Üê Executes one thing at a time</span>
<span class="cm">// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="cm">//          ‚Üë Event Loop moves tasks here</span>
<span class="cm">// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="cm">// ‚îÇ Microtask Queue ‚îÇ  ‚îÇ  Macrotask Queue     ‚îÇ</span>
<span class="cm">// ‚îÇ (drained first) ‚îÇ  ‚îÇ (one per iteration)  ‚îÇ</span>
<span class="cm">// ‚îÇ ‚Ä¢ Promise.then  ‚îÇ  ‚îÇ ‚Ä¢ setTimeout         ‚îÇ</span>
<span class="cm">// ‚îÇ ‚Ä¢ queueMicro.. ‚îÇ  ‚îÇ ‚Ä¢ setInterval        ‚îÇ</span>
<span class="cm">// ‚îÇ ‚Ä¢ MutationObs. ‚îÇ  ‚îÇ ‚Ä¢ DOM events         ‚îÇ</span>
<span class="cm">// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="cm">//                             ‚Üë callbacks come from</span>
<span class="cm">// ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="cm">// ‚îÇ                Web APIs                     ‚îÇ</span>
<span class="cm">// ‚îÇ    (setTimeout, fetch, addEventListener)    ‚îÇ</span>
<span class="cm">// ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is the microtask queue? Why do Promises resolve before setTimeout?</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>The microtask queue has <strong>higher priority</strong> than the macrotask queue. After every task finishes (and after the initial script), the engine checks the microtask queue and runs <em>every</em> microtask in it before moving on to the next macrotask. This draining is complete and recursive ‚Äî new microtasks added during microtask execution also run before any macrotask.</p>
  <pre><span class="cm">// Prove microtasks run before macrotasks</span>
console.<span class="fn">log</span>(<span class="str">'1: synchronous start'</span>);

setTimeout(() => console.<span class="fn">log</span>(<span class="str">'4: setTimeout'</span>), <span class="num">0</span>);  <span class="cm">// macrotask</span>

Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">'3: promise'</span>));  <span class="cm">// microtask</span>

console.<span class="fn">log</span>(<span class="str">'2: synchronous end'</span>);

<span class="cm">// Output: 1, 2, 3, 4</span>
<span class="cm">// Sync code runs first (1, 2)</span>
<span class="cm">// Then microtask queue drained (3)</span>
<span class="cm">// Then macrotask queue (4)</span>

<span class="cm">// Microtask starvation ‚Äî don't do this!</span>
<span class="kw">function</span> <span class="fn">queueForever</span>() {
  Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(<span class="fn">queueForever</span>); <span class="cm">// infinite microtask chain</span>
}
<span class="cm">// This would starve the macrotask queue ‚Äî UI freezes, no events processed</span></pre></div></div>

  <div class="qa"><div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">Predict the output: a complex event loop ordering problem.</span><span class="qa-tog">+</span></div>
  <div class="qa-a"><p>This is a classic interview question. Work through it by tracking what goes into each queue at each step.</p>
  <pre><span class="cm">// Predict the output ‚Äî solve step by step</span>
console.<span class="fn">log</span>(<span class="str">'A'</span>);

setTimeout(() => console.<span class="fn">log</span>(<span class="str">'B'</span>), <span class="num">0</span>);

Promise.<span class="fn">resolve</span>()
  .<span class="fn">then</span>(() => {
    console.<span class="fn">log</span>(<span class="str">'C'</span>);
    setTimeout(() => console.<span class="fn">log</span>(<span class="str">'D'</span>), <span class="num">0</span>);
    <span class="kw">return</span> <span class="str">'E-value'</span>;
  })
  .<span class="fn">then</span>(v => console.<span class="fn">log</span>(<span class="str">'E'</span>));

setTimeout(() => {
  console.<span class="fn">log</span>(<span class="str">'F'</span>);
  Promise.<span class="fn">resolve</span>().<span class="fn">then</span>(() => console.<span class="fn">log</span>(<span class="str">'G'</span>));
}, <span class="num">0</span>);

console.<span class="fn">log</span>(<span class="str">'H'</span>);</span>

<span class="cm">// Step-by-step:</span>
<span class="cm">// 1. Sync: log A</span>
<span class="cm">// 2. setTimeout(B,0) ‚Üí macrotask queue: [B]</span>
<span class="cm">// 3. Promise.then(C...) ‚Üí microtask queue: [C-handler]</span>
<span class="cm">// 4. setTimeout(F...,0) ‚Üí macrotask queue: [B, F]</span>
<span class="cm">// 5. Sync: log H</span>
<span class="cm">// 6. Microtasks drain: run C-handler</span>
<span class="cm">//    - log C</span>
<span class="cm">//    - setTimeout(D,0) ‚Üí macrotask: [B, F, D]</span>
<span class="cm">//    - return 'E-value' ‚Üí next .then queued: microtask [E-handler]</span>
<span class="cm">// 7. Microtasks still: run E-handler ‚Üí log E</span>
<span class="cm">// 8. Macrotask: B ‚Üí log B</span>
<span class="cm">// 9. Drain microtasks (empty)</span>
<span class="cm">// 10. Macrotask: F ‚Üí log F, queue microtask G</span>
<span class="cm">// 11. Drain microtasks: G ‚Üí log G</span>
<span class="cm">// 12. Macrotask: D ‚Üí log D</span></span>
  <div class="output-box"><div class="output-label">Output</div>
    <div class="output-line">A <span class="output-comment">‚Üê sync</span></div>
    <div class="output-line">H <span class="output-comment">‚Üê sync</span></div>
    <div class="output-line">C <span class="output-comment">‚Üê microtask</span></div>
    <div class="output-line">E <span class="output-comment">‚Üê microtask (chained)</span></div>
    <div class="output-line">B <span class="output-comment">‚Üê macrotask #1</span></div>
    <div class="output-line">F <span class="output-comment">‚Üê macrotask #2</span></div>
    <div class="output-line">G <span class="output-comment">‚Üê microtask (queued inside F)</span></div>
    <div class="output-line">D <span class="output-comment">‚Üê macrotask #3 (queued inside C)</span></div>
  </div></div></div>

  <div class="bottom-nav"><button class="btn" onclick="go('s7')">‚Üê Async JavaScript</button><button class="btn primary" onclick="go('s9')">Promises &amp; async/await ‚Üí</button></div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê S9: PROMISES & ASYNC/AWAIT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section" id="sec-s9">
  <div class="section-head">
    <div class="sec-num">09</div>
    <div><div class="sec-title">Promises & async/await</div><div class="sec-sub">Mastering modern asynchronous JavaScript patterns</div></div>
  </div>
  <div class="topic-row">
    <span class="topic">Promise Internals</span><span class="topic">async Functions</span><span class="topic">await Mechanics</span><span class="topic g">Error Handling</span><span class="topic r">try/catch</span><span class="topic b">Parallel vs Sequential</span><span class="topic">Promise.all</span><span class="topic">Promise.allSettled</span>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What does async/await actually do under the hood? How does it relate to Promises?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p><code>async</code>/<code>await</code> is <strong>syntactic sugar over Promises</strong> ‚Äî it doesn't introduce new async capabilities. It just makes Promise-based code look and read like synchronous code, eliminating the need for <code>.then()</code> chains. Under the hood, the JavaScript engine transforms <code>async</code>/<code>await</code> into Promise chains automatically.</p>
      <h4>async functions always return a Promise</h4>
      <p>Even if you <code>return 42</code> from an async function, the caller receives <code>Promise.resolve(42)</code>. If you throw inside an async function, the returned Promise rejects with that error.</p>
      <h4>await pauses execution within the async function</h4>
      <p><code>await</code> can only be used inside <code>async</code> functions. It pauses the current async function, allowing other code on the call stack to run, then resumes when the awaited Promise settles. Under the hood, the resumption is queued as a <em>microtask</em>.</p>
      <pre><span class="cm">// These two are functionally identical:</span>

<span class="cm">// Promise chain version</span>
<span class="kw">function</span> <span class="fn">fetchUser</span>(id) {
  <span class="kw">return</span> <span class="fn">fetch</span>(<span class="str">`/api/users/${id}`</span>)
    .<span class="fn">then</span>(res => res.<span class="fn">json</span>())
    .<span class="fn">then</span>(user => {
      console.<span class="fn">log</span>(user.name);
      <span class="kw">return</span> user;
    });
}

<span class="cm">// async/await version</span>
<span class="kw">async function</span> <span class="fn">fetchUser</span>(id) {
  <span class="kw">const</span> res  = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">`/api/users/${id}`</span>);
  <span class="kw">const</span> user = <span class="kw">await</span> res.<span class="fn">json</span>();
  console.<span class="fn">log</span>(user.name);
  <span class="kw">return</span> user; <span class="cm">// caller gets Promise&lt;user&gt;</span>
}

<span class="cm">// async always returns a Promise</span>
<span class="kw">async function</span> <span class="fn">getValue</span>() { <span class="kw">return</span> <span class="num">42</span>; }
<span class="fn">getValue</span>(); <span class="cm">// Promise { 42 } ‚Äî not 42</span>
<span class="kw">const</span> v = <span class="kw">await</span> <span class="fn">getValue</span>(); <span class="cm">// 42 ‚Äî unwrapped with await</span>

<span class="cm">// async returning a promise</span>
<span class="kw">async function</span> <span class="fn">failing</span>() {
  <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="str">'Something went wrong'</span>);
}
<span class="cm">// equivalent to:</span>
<span class="kw">function</span> <span class="fn">failing2</span>() {
  <span class="kw">return</span> Promise.<span class="fn">reject</span>(<span class="kw">new</span> Error(<span class="str">'Something went wrong'</span>));
}</pre>
      <div class="callout info"><div class="callout-title">‚ÑπÔ∏è await Internals</div><p>When the engine hits <code>await somePromise</code>, it: (1) suspends the current async function, (2) registers a microtask to resume when <code>somePromise</code> settles, and (3) returns control to the caller. When the Promise settles, the microtask fires and execution resumes from where it paused. This is why <code>await</code> has no cost when the Promise is already resolved.</p></div>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">How do you handle errors in async/await? What happens if you don't?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>With async/await, error handling uses standard <code>try/catch</code> blocks ‚Äî the same mechanism used for synchronous errors. This is one of async/await's biggest advantages: unified error handling. If you don't handle errors, the Promise returned by the async function rejects silently, which can lead to unhandled promise rejection warnings (or crashes in Node.js).</p>
      <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Basic try/catch ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">async function</span> <span class="fn">loadUser</span>(id) {
  <span class="kw">try</span> {
    <span class="kw">const</span> res  = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">`/api/users/${id}`</span>);
    <span class="kw">if</span> (!res.ok) <span class="kw">throw</span> <span class="kw">new</span> Error(<span class="str">`HTTP ${res.status}`</span>);
    <span class="kw">const</span> user = <span class="kw">await</span> res.<span class="fn">json</span>();
    <span class="kw">return</span> user;
  } <span class="kw">catch</span> (err) {
    <span class="cm">// catches: network errors, non-ok responses, JSON parse errors</span>
    console.<span class="fn">error</span>(<span class="str">'Failed to load user:'</span>, err.message);
    <span class="kw">return</span> <span class="kw">null</span>; <span class="cm">// return a safe default instead of crashing</span>
  } <span class="kw">finally</span> {
    <span class="cm">// always runs regardless of success or failure</span>
    console.<span class="fn">log</span>(<span class="str">'Request complete'</span>);
  }
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ Handling errors without try/catch ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// You can still use .catch() on async functions</span>
<span class="fn">loadUser</span>(<span class="num">123</span>).<span class="fn">catch</span>(err => console.<span class="fn">error</span>(err));

<span class="cm">// ‚îÄ‚îÄ‚îÄ Per-await error handling ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">async function</span> <span class="fn">riskyOps</span>() {
  <span class="cm">// Handle specific awaits individually</span>
  <span class="kw">let</span> user;
  <span class="kw">try</span> {
    user = <span class="kw">await</span> <span class="fn">fetchUser</span>(<span class="num">1</span>);
  } <span class="kw">catch</span> {
    user = { name: <span class="str">'Guest'</span> }; <span class="cm">// fallback user</span>
  }

  <span class="kw">let</span> posts;
  <span class="kw">try</span> {
    posts = <span class="kw">await</span> <span class="fn">fetchPosts</span>(user.id);
  } <span class="kw">catch</span> {
    posts = []; <span class="cm">// empty fallback</span>
  }

  <span class="kw">return</span> { user, posts }; <span class="cm">// always returns something</span>
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ Unhandled rejection ‚Äî DON'T DO THIS ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">async function</span> <span class="fn">noErrorHandling</span>() {
  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'bad-url'</span>); <span class="cm">// throws, no catch</span>
  <span class="kw">return</span> data; <span class="cm">// never reached</span>
}
<span class="cm">// noErrorHandling() ‚Üí Promise.reject(NetworkError)</span>
<span class="cm">// Without .catch() or try/catch ‚Üí unhandledRejection warning</span></pre>
      <div class="callout danger"><div class="callout-title">üö® Common Mistake: Forgetting await</div><p>If you forget <code>await</code>, you get a Promise object instead of the resolved value. The code continues synchronously without waiting. This is one of the most common async/await bugs.</p></div>
      <pre><span class="cm">// ‚ùå Forgot await ‚Äî data is a Promise, not the value!</span>
<span class="kw">async function</span> <span class="fn">broken</span>() {
  <span class="kw">const</span> data = <span class="fn">fetch</span>(<span class="str">'/api'</span>); <span class="cm">// Promise&lt;Response&gt;, not Response</span>
  console.<span class="fn">log</span>(data.status);  <span class="cm">// undefined (Promise has no .status)</span>
}

<span class="cm">// ‚úÖ With await</span>
<span class="kw">async function</span> <span class="fn">correct</span>() {
  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api'</span>); <span class="cm">// Response object</span>
  console.<span class="fn">log</span>(data.status);         <span class="cm">// 200</span>
}</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is the difference between sequential and parallel execution of Promises?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>This is one of the most critical performance topics in async JavaScript. <strong>Sequential execution</strong> awaits each Promise before starting the next ‚Äî the total time is the sum of all durations. <strong>Parallel execution</strong> starts all Promises simultaneously ‚Äî the total time is the duration of the <em>slowest</em> one.</p>
      <pre><span class="cm">// Simulate async operations</span>
<span class="kw">const</span> <span class="fn">fetchUser</span>   = () => <span class="kw">new</span> Promise(r => setTimeout(() => r(<span class="str">'user'</span>),   <span class="num">1000</span>));
<span class="kw">const</span> <span class="fn">fetchPosts</span>  = () => <span class="kw">new</span> Promise(r => setTimeout(() => r(<span class="str">'posts'</span>),  <span class="num">1200</span>));
<span class="kw">const</span> <span class="fn">fetchOrders</span> = () => <span class="kw">new</span> Promise(r => setTimeout(() => r(<span class="str">'orders'</span>), <span class="num">800</span>));

<span class="cm">// ‚ùå SEQUENTIAL ‚Äî total wait: 1000 + 1200 + 800 = 3000ms</span>
<span class="kw">async function</span> <span class="fn">loadSequential</span>() {
  <span class="kw">const</span> user   = <span class="kw">await</span> <span class="fn">fetchUser</span>();    <span class="cm">// wait 1000ms</span>
  <span class="kw">const</span> posts  = <span class="kw">await</span> <span class="fn">fetchPosts</span>();   <span class="cm">// then wait 1200ms</span>
  <span class="kw">const</span> orders = <span class="kw">await</span> <span class="fn">fetchOrders</span>();  <span class="cm">// then wait 800ms</span>
  <span class="kw">return</span> { user, posts, orders };
}

<span class="cm">// ‚úÖ PARALLEL ‚Äî total wait: max(1000, 1200, 800) = 1200ms</span>
<span class="kw">async function</span> <span class="fn">loadParallel</span>() {
  <span class="kw">const</span> [user, posts, orders] = <span class="kw">await</span> Promise.<span class="fn">all</span>([
    <span class="fn">fetchUser</span>(),    <span class="cm">// all three started simultaneously</span>
    <span class="fn">fetchPosts</span>(),
    <span class="fn">fetchOrders</span>()
  ]);
  <span class="kw">return</span> { user, posts, orders };
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ When to use sequential ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// Use sequential when the RESULT of one request is NEEDED for the next</span>
<span class="kw">async function</span> <span class="fn">loadUserThenPosts</span>() {
  <span class="kw">const</span> user  = <span class="kw">await</span> <span class="fn">fetchUser</span>();        <span class="cm">// need user.id first</span>
  <span class="kw">const</span> posts = <span class="kw">await</span> <span class="fn">fetchPostsByUser</span>(user.id); <span class="cm">// uses user.id</span>
  <span class="kw">return</span> { user, posts };
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ Starting in parallel, awaiting together ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// A common pattern: kick off requests, then await results</span>
<span class="kw">async function</span> <span class="fn">loadAll</span>() {
  <span class="kw">const</span> userPromise   = <span class="fn">fetchUser</span>();    <span class="cm">// STARTED immediately</span>
  <span class="kw">const</span> postsPromise  = <span class="fn">fetchPosts</span>();   <span class="cm">// STARTED immediately</span>
  <span class="kw">const</span> ordersPromise = <span class="fn">fetchOrders</span>(); <span class="cm">// STARTED immediately</span>

  <span class="kw">const</span> user   = <span class="kw">await</span> userPromise;    <span class="cm">// await results</span>
  <span class="kw">const</span> posts  = <span class="kw">await</span> postsPromise;
  <span class="kw">const</span> orders = <span class="kw">await</span> ordersPromise;
  <span class="kw">return</span> { user, posts, orders };       <span class="cm">// ~1200ms total</span>
}</pre>
      <div class="callout warn"><div class="callout-title">‚ö° Interview Insight</div><p>Using sequential <code>await</code> when requests are independent is a very common performance anti-pattern. In interviews, when asked to fetch multiple independent resources, always reach for <code>Promise.all()</code> first.</p></div>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">Explain all Promise combinator methods: all, allSettled, race, any.</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <table>
        <tr><th>Method</th><th>Resolves when</th><th>Rejects when</th><th>Use case</th></tr>
        <tr><td>Promise.all()</td><td>ALL resolve</td><td>ANY rejects (fast-fail)</td><td>Parallel independent requests, all required</td></tr>
        <tr><td>Promise.allSettled()</td><td>ALL settle (any state)</td><td>Never rejects</td><td>Fire-and-forget, report on all outcomes</td></tr>
        <tr><td>Promise.race()</td><td>FIRST settles (any state)</td><td>FIRST settles (if rejection)</td><td>Timeout patterns, fastest wins</td></tr>
        <tr><td>Promise.any()</td><td>FIRST resolves</td><td>ALL reject (AggregateError)</td><td>Redundant requests, first success wins</td></tr>
      </table>
      <pre><span class="kw">const</span> <span class="fn">p1</span> = Promise.<span class="fn">resolve</span>(<span class="str">'A'</span>);
<span class="kw">const</span> <span class="fn">p2</span> = Promise.<span class="fn">reject</span>(<span class="kw">new</span> Error(<span class="str">'B failed'</span>));
<span class="kw">const</span> <span class="fn">p3</span> = Promise.<span class="fn">resolve</span>(<span class="str">'C'</span>);

<span class="cm">// Promise.all ‚Äî all must succeed</span>
Promise.<span class="fn">all</span>([p1, p3])
  .<span class="fn">then</span>(([a, c]) => console.<span class="fn">log</span>(a, c));  <span class="cm">// 'A', 'C'</span>
Promise.<span class="fn">all</span>([p1, p2, p3])
  .<span class="fn">catch</span>(err => console.<span class="fn">error</span>(err));  <span class="cm">// Error: B failed (p1, p3 ignored)</span>

<span class="cm">// Promise.allSettled ‚Äî always resolves with status report</span>
Promise.<span class="fn">allSettled</span>([p1, p2, p3])
  .<span class="fn">then</span>(results => {
    <span class="cm">// [{ status:'fulfilled', value:'A' },</span>
    <span class="cm">//  { status:'rejected',  reason: Error('B failed') },</span>
    <span class="cm">//  { status:'fulfilled', value:'C' }]</span>
    results.<span class="fn">forEach</span>(r => {
      <span class="kw">if</span> (r.status === <span class="str">'fulfilled'</span>) console.<span class="fn">log</span>(<span class="str">'‚úÖ'</span>, r.value);
      <span class="kw">else</span> console.<span class="fn">log</span>(<span class="str">'‚ùå'</span>, r.reason.message);
    });
  });

<span class="cm">// Promise.race ‚Äî first to settle wins</span>
<span class="kw">const</span> <span class="fn">timeout</span> = <span class="kw">new</span> Promise((_, reject) =>
  setTimeout(() => reject(<span class="kw">new</span> Error(<span class="str">'Timeout'</span>)), <span class="num">5000</span>)
);
Promise.<span class="fn">race</span>([<span class="fn">fetchData</span>(), timeout])
  .<span class="fn">then</span>(data => console.<span class="fn">log</span>(data))
  .<span class="fn">catch</span>(err => console.<span class="fn">error</span>(err)); <span class="cm">// Timeout if fetch > 5s</span>

<span class="cm">// Promise.any ‚Äî first SUCCESS wins (ignores rejections)</span>
Promise.<span class="fn">any</span>([
  <span class="fn">fetch</span>(<span class="str">'https://server1.example.com/api'</span>),
  <span class="fn">fetch</span>(<span class="str">'https://server2.example.com/api'</span>),
  <span class="fn">fetch</span>(<span class="str">'https://server3.example.com/api'</span>)
]).<span class="fn">then</span>(res => console.<span class="fn">log</span>(<span class="str">'Fastest server responded'</span>, res));
<span class="cm">// Uses whichever server responds first (redundant requests for reliability)</span></pre>
    </div>
  </div>

  <div class="bottom-nav">
    <button class="btn" onclick="go('s8')">‚Üê Event Loop</button>
    <button class="btn primary" onclick="go('s10')">Browser & Events ‚Üí</button>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê S10: BROWSER & EVENTS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section" id="sec-s10">
  <div class="section-head">
    <div class="sec-num">10</div>
    <div><div class="sec-title">Browser APIs & DOM Events</div><div class="sec-sub">Bubbling, delegation, debounce, throttle ‚Äî all explained</div></div>
  </div>
  <div class="topic-row">
    <span class="topic">Event Bubbling</span><span class="topic">Event Capturing</span><span class="topic">Event Delegation</span><span class="topic r">stopPropagation</span><span class="topic r">preventDefault</span><span class="topic g">Debounce</span><span class="topic g">Throttle</span>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What is event bubbling and event capturing? What is the order of execution?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>When an event fires on a DOM element, it doesn't stay isolated to that element. It <em>propagates</em> through the DOM tree in three phases:</p>
      <ul>
        <li><strong>Phase 1 ‚Äî Capture</strong>: Event travels from the <code>window</code> down through ancestors to the target element. Handlers registered with <code>useCapture: true</code> fire during this phase.</li>
        <li><strong>Phase 2 ‚Äî Target</strong>: Event reaches the element that was actually clicked. Both capture and bubble handlers fire here.</li>
        <li><strong>Phase 3 ‚Äî Bubble</strong>: Event travels back up from the target to <code>window</code>. Most handlers use this phase (the default).</li>
      </ul>
      <pre><span class="cm">// HTML structure:</span>
<span class="cm">// &lt;div id="outer"&gt;</span>
<span class="cm">//   &lt;div id="middle"&gt;</span>
<span class="cm">//     &lt;button id="inner"&gt;Click&lt;/button&gt;</span>
<span class="cm">//   &lt;/div&gt;</span>
<span class="cm">// &lt;/div&gt;</span>

<span class="kw">const</span> outer  = document.<span class="fn">getElementById</span>(<span class="str">'outer'</span>);
<span class="kw">const</span> middle = document.<span class="fn">getElementById</span>(<span class="str">'middle'</span>);
<span class="kw">const</span> inner  = document.<span class="fn">getElementById</span>(<span class="str">'inner'</span>);

<span class="cm">// Default: bubble phase (3rd arg false/omitted)</span>
outer.<span class="fn">addEventListener</span>(<span class="str">'click'</span>,  () => console.<span class="fn">log</span>(<span class="str">'outer bubble'</span>));
middle.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, () => console.<span class="fn">log</span>(<span class="str">'middle bubble'</span>));
inner.<span class="fn">addEventListener</span>(<span class="str">'click'</span>,  () => console.<span class="fn">log</span>(<span class="str">'inner (target)'</span>));

<span class="cm">// Capture phase (3rd arg true)</span>
outer.<span class="fn">addEventListener</span>(<span class="str">'click'</span>,  () => console.<span class="fn">log</span>(<span class="str">'outer capture'</span>), <span class="kw">true</span>);
middle.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, () => console.<span class="fn">log</span>(<span class="str">'middle capture'</span>), <span class="kw">true</span>);

<span class="cm">// Click on #inner ‚Üí execution order:</span>
<span class="cm">// 1. outer capture   ‚Üê Phase 1: descending</span>
<span class="cm">// 2. middle capture  ‚Üê Phase 1: descending</span>
<span class="cm">// 3. inner (target)  ‚Üê Phase 2: target</span>
<span class="cm">// 4. middle bubble   ‚Üê Phase 3: ascending</span>
<span class="cm">// 5. outer bubble    ‚Üê Phase 3: ascending</span>

<span class="cm">// event.target vs event.currentTarget</span>
outer.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
  console.<span class="fn">log</span>(e.target);         <span class="cm">// the element that was clicked (inner button)</span>
  console.<span class="fn">log</span>(e.currentTarget);  <span class="cm">// the element with this handler (outer div)</span>
});</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is event delegation and why is it a performance optimization?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p><strong>Event delegation</strong> is a pattern where instead of adding event listeners to many individual child elements, you add a single listener to a common parent element and use <code>event.target</code> to determine which child was clicked. This works because of event bubbling ‚Äî clicks on children bubble up to the parent.</p>
      <h4>Why it's better:</h4>
      <ul>
        <li><strong>Memory:</strong> One listener instead of hundreds. Each event listener consumes memory.</li>
        <li><strong>Dynamic elements:</strong> Works automatically for elements added to the DOM after the listener was set up ‚Äî you don't need to re-add listeners.</li>
        <li><strong>Setup cost:</strong> No need to loop through every element and attach handlers.</li>
      </ul>
      <pre><span class="cm">// ‚ùå Without delegation ‚Äî one listener PER item (scales poorly)</span>
<span class="kw">const</span> items = document.<span class="fn">querySelectorAll</span>(<span class="str">'li'</span>);
items.<span class="fn">forEach</span>(item => {
  item.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, () => console.<span class="fn">log</span>(item.textContent));
});
<span class="cm">// 1000 items = 1000 event listeners!</span>
<span class="cm">// Also: dynamically added items won't have listeners!</span>

<span class="cm">// ‚úÖ With delegation ‚Äî ONE listener on the parent</span>
<span class="kw">const</span> list = document.<span class="fn">getElementById</span>(<span class="str">'my-list'</span>);
list.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
  <span class="cm">// Check if a list item was clicked (not the list itself)</span>
  <span class="kw">if</span> (e.target.tagName === <span class="str">'LI'</span>) {
    console.<span class="fn">log</span>(<span class="str">'Clicked:'</span>, e.target.textContent);
    e.target.<span class="fn">classList</span>.<span class="fn">toggle</span>(<span class="str">'selected'</span>);
  }
});
<span class="cm">// 1000 items = still 1 event listener!</span>
<span class="cm">// Dynamically added LIs are handled automatically!</span>

<span class="cm">// More sophisticated delegation with data attributes</span>
document.<span class="fn">getElementById</span>(<span class="str">'app'</span>).<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
  <span class="kw">const</span> btn = e.target.<span class="fn">closest</span>(<span class="str">'[data-action]'</span>); <span class="cm">// walk up to action element</span>
  <span class="kw">if</span> (!btn) <span class="kw">return</span>;

  <span class="kw">const</span> action = btn.dataset.action;
  <span class="kw">const</span> id     = btn.dataset.id;

  <span class="kw">if</span> (action === <span class="str">'delete'</span>) <span class="fn">deleteItem</span>(id);
  <span class="kw">if</span> (action === <span class="str">'edit'</span>)   <span class="fn">editItem</span>(id);
  <span class="kw">if</span> (action === <span class="str">'save'</span>)   <span class="fn">saveItem</span>(id);
});</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is the difference between stopPropagation and preventDefault?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>These are two completely different methods that do completely different things ‚Äî a common point of confusion.</p>
      <p><code>e.stopPropagation()</code> stops the event from traveling further up (or down) the DOM tree. It prevents parent element handlers from running, but the browser's default behavior is unaffected.</p>
      <p><code>e.preventDefault()</code> prevents the browser's built-in default action for that event, but the event still propagates normally through the DOM.</p>
      <pre><span class="cm">// stopPropagation ‚Äî stops event from reaching parent handlers</span>
child.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
  e.<span class="fn">stopPropagation</span>(); <span class="cm">// parent's click handler won't fire</span>
  console.<span class="fn">log</span>(<span class="str">'child clicked'</span>);
});
parent.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, () => {
  console.<span class="fn">log</span>(<span class="str">'parent ‚Äî this won\'t log'</span>);
});

<span class="cm">// preventDefault ‚Äî prevents browser default action</span>
<span class="kw">const</span> link = document.<span class="fn">querySelector</span>(<span class="str">'a'</span>);
link.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
  e.<span class="fn">preventDefault</span>(); <span class="cm">// stops navigation to href</span>
  console.<span class="fn">log</span>(<span class="str">'link clicked ‚Äî but no navigation'</span>);
  <span class="cm">// event STILL BUBBLES to parent handlers</span>
});

<span class="kw">const</span> form = document.<span class="fn">querySelector</span>(<span class="str">'form'</span>);
form.<span class="fn">addEventListener</span>(<span class="str">'submit'</span>, (e) => {
  e.<span class="fn">preventDefault</span>(); <span class="cm">// stops form from submitting (page reload)</span>
  <span class="fn">handleSubmit</span>(e);     <span class="cm">// handle with JavaScript instead</span>
});

<span class="cm">// stopImmediatePropagation ‚Äî stops other handlers ON THE SAME element too</span>
btn.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, (e) => {
  e.<span class="fn">stopImmediatePropagation</span>();
  console.<span class="fn">log</span>(<span class="str">'first handler ‚Äî only this runs'</span>);
});
btn.<span class="fn">addEventListener</span>(<span class="str">'click'</span>, () => {
  console.<span class="fn">log</span>(<span class="str">'second handler ‚Äî this never runs'</span>);
});</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">What is debounce? Implement it from scratch and explain its use cases.</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p><strong>Debouncing</strong> ensures that a function only fires after a quiet period ‚Äî after the user has stopped performing an action for a specified delay. Each new event resets the timer. If events keep coming before the delay expires, the function never fires. Only when there's a pause longer than the delay does the function execute.</p>
      <p><strong>Mental model:</strong> "Wait until the user stops typing for 300ms, then search."</p>
      <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Debounce implementation ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">function</span> <span class="fn">debounce</span>(fn, delay) {
  <span class="kw">let</span> timerId;                     <span class="cm">// closed over ‚Äî persists between calls</span>

  <span class="kw">return</span> <span class="kw">function</span>(...args) {
    clearTimeout(timerId);          <span class="cm">// cancel any pending call</span>
    timerId = setTimeout(() => {    <span class="cm">// schedule a new call</span>
      <span class="fn">fn</span>.<span class="fn">apply</span>(<span class="kw">this</span>, args);          <span class="cm">// call with correct 'this' and args</span>
    }, delay);
  };
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ Usage ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">function</span> <span class="fn">searchAPI</span>(query) {
  console.<span class="fn">log</span>(<span class="str">`Searching: ${query}`</span>);
  <span class="cm">// fetch(`/api/search?q=${query}`)</span>
}

<span class="kw">const</span> <span class="fn">debouncedSearch</span> = <span class="fn">debounce</span>(searchAPI, <span class="num">300</span>);

<span class="cm">// User types rapidly ‚Äî only the last call (after 300ms pause) fires</span>
input.<span class="fn">addEventListener</span>(<span class="str">'input'</span>, (e) => <span class="fn">debouncedSearch</span>(e.target.value));
<span class="cm">// User types: 'r', 'e', 'a', 'c', 't' (each within 300ms of previous)</span>
<span class="cm">// ‚Üí only 'react' triggers the API call (once they stop typing)</span>

<span class="cm">// Common use cases for debounce:</span>
<span class="cm">// - Search-as-you-type (avoid spamming the API)</span>
<span class="cm">// - Auto-save (save 500ms after user stops editing)</span>
<span class="cm">// - Window resize handlers (recalculate layout after resize finishes)</span>
<span class="cm">// - Form validation (validate after user stops typing)</span>

<span class="cm">// Leading edge debounce ‚Äî fires immediately, then blocks until quiet</span>
<span class="kw">function</span> <span class="fn">debounceLeading</span>(fn, delay) {
  <span class="kw">let</span> timerId;
  <span class="kw">return</span> <span class="kw">function</span>(...args) {
    <span class="kw">const</span> callNow = !timerId;        <span class="cm">// fire if no pending timer</span>
    clearTimeout(timerId);
    timerId = setTimeout(() => {
      timerId = <span class="kw">null</span>;               <span class="cm">// reset after quiet period</span>
    }, delay);
    <span class="kw">if</span> (callNow) <span class="fn">fn</span>.<span class="fn">apply</span>(<span class="kw">this</span>, args);
  };
}</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.05</span><span class="qa-text">What is throttle? How is it different from debounce? Implement it from scratch.</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p><strong>Throttling</strong> limits how often a function can fire ‚Äî it guarantees execution at most once per interval. Unlike debounce, throttle fires immediately on the first call, and then blocks subsequent calls until the interval has passed.</p>
      <p><strong>Mental model:</strong> "Fire at most once every 100ms, no matter how fast the user scrolls."</p>
      <table>
        <tr><th></th><th>Debounce</th><th>Throttle</th></tr>
        <tr><td>Fires when</td><td>After quiet period</td><td>Every N milliseconds</td></tr>
        <tr><td>During rapid events</td><td>Resets timer, delays execution</td><td>Fires at consistent intervals</td></tr>
        <tr><td>Best for</td><td>Search input, auto-save</td><td>Scroll, mouse move, resize</td></tr>
        <tr><td>Guarantee</td><td>Function fires after action stops</td><td>Function fires at most once/interval</td></tr>
      </table>
      <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Throttle implementation ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">function</span> <span class="fn">throttle</span>(fn, limit) {
  <span class="kw">let</span> inThrottle = <span class="kw">false</span>;           <span class="cm">// tracks if we're in a blocked period</span>

  <span class="kw">return</span> <span class="kw">function</span>(...args) {
    <span class="kw">if</span> (inThrottle) <span class="kw">return</span>;          <span class="cm">// block: still within the limit period</span>

    <span class="fn">fn</span>.<span class="fn">apply</span>(<span class="kw">this</span>, args);             <span class="cm">// execute the function</span>
    inThrottle = <span class="kw">true</span>;               <span class="cm">// enter blocking period</span>

    setTimeout(() => {
      inThrottle = <span class="kw">false</span>;            <span class="cm">// unblock after limit</span>
    }, limit);
  };
}

<span class="cm">// ‚îÄ‚îÄ‚îÄ Usage ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">function</span> <span class="fn">handleScroll</span>() {
  console.<span class="fn">log</span>(<span class="str">'Scroll position:'</span>, window.scrollY);
  <span class="cm">// expensive: update parallax, lazy load, calculate positions</span>
}

<span class="kw">const</span> <span class="fn">throttledScroll</span> = <span class="fn">throttle</span>(handleScroll, <span class="num">100</span>);
window.<span class="fn">addEventListener</span>(<span class="str">'scroll'</span>, throttledScroll);
<span class="cm">// User scrolls 60fps (every 16ms)</span>
<span class="cm">// But handleScroll only runs every 100ms ‚Äî ~10 times/second max</span>

<span class="cm">// Other throttle use cases:</span>
<span class="cm">// - Scroll event handlers (parallax, infinite scroll)</span>
<span class="cm">// - Mouse move (drag and drop, hover effects)</span>
<span class="cm">// - Game input handling (fire rate limits)</span>
<span class="cm">// - Analytics event tracking</span>
<span class="cm">// - API rate limit compliance</span></pre>
    </div>
  </div>

  <div class="bottom-nav">
    <button class="btn" onclick="go('s9')">‚Üê Promises & async/await</button>
    <button class="btn primary" onclick="go('s11')">Advanced Concepts ‚Üí</button>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê S11: ADVANCED ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section" id="sec-s11">
  <div class="section-head">
    <div class="sec-num">11</div>
    <div><div class="sec-title">Advanced Concepts</div><div class="sec-sub">Observers, requestAnimationFrame, generators, and real-world patterns</div></div>
  </div>
  <div class="topic-row">
    <span class="topic">Intersection Observer</span><span class="topic">Mutation Observer</span><span class="topic b">requestAnimationFrame</span><span class="topic g">Generators</span><span class="topic">Retry Logic</span><span class="topic r">Memory Leaks</span>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.01</span><span class="qa-text">What is the Intersection Observer API? How do you use it for lazy loading?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>The <strong>Intersection Observer API</strong> lets you asynchronously observe whether a DOM element has entered or exited the browser's viewport (or another ancestor element). It's far more performant than the old approach of listening to scroll events and calling <code>getBoundingClientRect()</code> on every scroll ‚Äî that method forces layout reflow on every call.</p>
      <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Basic Intersection Observer ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> observer = <span class="kw">new</span> <span class="fn">IntersectionObserver</span>((entries, observer) => {
  entries.<span class="fn">forEach</span>(entry => {
    <span class="kw">if</span> (entry.isIntersecting) {
      <span class="cm">// Element has entered the viewport</span>
      console.<span class="fn">log</span>(entry.target, <span class="str">'is visible'</span>);
      console.<span class="fn">log</span>(entry.intersectionRatio);  <span class="cm">// 0.0 to 1.0</span>

      <span class="cm">// Optionally stop observing after first intersection</span>
      observer.<span class="fn">unobserve</span>(entry.target);
    }
  });
}, {
  threshold: <span class="num">0.1</span>,        <span class="cm">// fire when 10% of element is visible</span>
  rootMargin: <span class="str">'100px'</span>   <span class="cm">// expand/contract viewport by 100px</span>
});

<span class="cm">// Observe all images</span>
document.<span class="fn">querySelectorAll</span>(<span class="str">'img[data-src]'</span>).<span class="fn">forEach</span>(img => {
  observer.<span class="fn">observe</span>(img);
});

<span class="cm">// ‚îÄ‚îÄ‚îÄ Lazy loading images ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> lazyObserver = <span class="kw">new</span> <span class="fn">IntersectionObserver</span>((entries) => {
  entries.<span class="fn">forEach</span>(entry => {
    <span class="kw">if</span> (!entry.isIntersecting) <span class="kw">return</span>;

    <span class="kw">const</span> img = entry.target;
    img.src = img.dataset.src;        <span class="cm">// swap placeholder for real src</span>
    img.<span class="fn">classList</span>.<span class="fn">remove</span>(<span class="str">'lazy'</span>);   <span class="cm">// remove loading class</span>
    lazyObserver.<span class="fn">unobserve</span>(img);    <span class="cm">// stop watching this image</span>
  });
}, { rootMargin: <span class="str">'200px'</span> });        <span class="cm">// load 200px before entering viewport</span>

<span class="cm">// ‚îÄ‚îÄ‚îÄ Scroll animations ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> animObserver = <span class="kw">new</span> <span class="fn">IntersectionObserver</span>((entries) => {
  entries.<span class="fn">forEach</span>(entry => {
    entry.target.<span class="fn">classList</span>.<span class="fn">toggle</span>(<span class="str">'animate-in'</span>, entry.isIntersecting);
  });
}, { threshold: <span class="num">0.2</span> });

document.<span class="fn">querySelectorAll</span>(<span class="str">'.reveal'</span>).<span class="fn">forEach</span>(el => animObserver.<span class="fn">observe</span>(el));</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.02</span><span class="qa-text">What is the Mutation Observer API? When would you use it?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>The <strong>Mutation Observer API</strong> lets you observe changes to the DOM tree ‚Äî element additions/removals, attribute changes, text content changes. It replaced the deprecated DOM Mutation Events because it batches changes and delivers them asynchronously as microtasks, avoiding performance issues.</p>
      <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Basic MutationObserver ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">const</span> observer = <span class="kw">new</span> <span class="fn">MutationObserver</span>((mutations) => {
  mutations.<span class="fn">forEach</span>(mutation => {
    console.<span class="fn">log</span>(<span class="str">'Type:'</span>, mutation.type);          <span class="cm">// childList | attributes | characterData</span>
    console.<span class="fn">log</span>(<span class="str">'Target:'</span>, mutation.target);
    console.<span class="fn">log</span>(<span class="str">'Added:'</span>, mutation.addedNodes);
    console.<span class="fn">log</span>(<span class="str">'Removed:'</span>, mutation.removedNodes);
    console.<span class="fn">log</span>(<span class="str">'Old attr:'</span>, mutation.oldValue);  <span class="cm">// if attributeOldValue: true</span>
  });
});

<span class="kw">const</span> targetNode = document.<span class="fn">getElementById</span>(<span class="str">'app'</span>);
observer.<span class="fn">observe</span>(targetNode, {
  childList: <span class="kw">true</span>,        <span class="cm">// watch for child add/remove</span>
  subtree: <span class="kw">true</span>,          <span class="cm">// watch all descendants</span>
  attributes: <span class="kw">true</span>,       <span class="cm">// watch attribute changes</span>
  characterData: <span class="kw">true</span>,    <span class="cm">// watch text content changes</span>
  attributeOldValue: <span class="kw">true</span> <span class="cm">// record previous attribute values</span>
});

<span class="cm">// Stop observing</span>
observer.<span class="fn">disconnect</span>();

<span class="cm">// ‚îÄ‚îÄ‚îÄ Use cases ‚îÄ‚îÄ‚îÄ</span>
<span class="cm">// 1. Custom elements: react when children are added/removed</span>
<span class="cm">// 2. Third-party integrations: detect when library changes DOM</span>
<span class="cm">// 3. Accessibility: announce dynamic content changes to screen readers</span>
<span class="cm">// 4. Analytics: track DOM changes as user events</span>
<span class="cm">// 5. Virtual DOM diffing (conceptually similar)</span></pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.03</span><span class="qa-text">What is requestAnimationFrame and why is it better than setInterval for animations?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p><code>requestAnimationFrame</code> (rAF) tells the browser: "Run this callback right before the next repaint." The browser calls your function at the optimal moment ‚Äî typically 60 times per second (every ~16.67ms) on 60Hz displays, or 120fps on high-refresh screens. This synchronizes your animation with the display refresh cycle.</p>
      <table>
        <tr><th></th><th>requestAnimationFrame</th><th>setInterval(fn, 16)</th></tr>
        <tr><td>Timing</td><td>Synced to display refresh</td><td>Fixed interval (imprecise)</td></tr>
        <tr><td>Background tab</td><td>Pauses (saves CPU/battery)</td><td>Keeps running (wastes resources)</td></tr>
        <tr><td>Precision</td><td>Very high (browser-optimized)</td><td>Lower (timer drift)</td></tr>
        <tr><td>Jank</td><td>Minimal</td><td>Can cause visual stutter</td></tr>
        <tr><td>Callback arg</td><td>DOMHighResTimeStamp</td><td>None</td></tr>
      </table>
      <pre><span class="cm">// ‚îÄ‚îÄ‚îÄ Animation loop with rAF ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">let</span> position = <span class="num">0</span>;
<span class="kw">let</span> animationId;

<span class="kw">function</span> <span class="fn">animate</span>(timestamp) {
  <span class="cm">// timestamp = DOMHighResTimeStamp (ms since page load)</span>
  position += <span class="num">2</span>;
  element.style.transform = <span class="str">`translateX(${position}px)`</span>;

  <span class="kw">if</span> (position &lt; <span class="num">500</span>) {
    animationId = requestAnimationFrame(<span class="fn">animate</span>); <span class="cm">// schedule next frame</span>
  }
}

<span class="cm">// Start</span>
animationId = requestAnimationFrame(<span class="fn">animate</span>);

<span class="cm">// Stop anytime</span>
cancelAnimationFrame(animationId);

<span class="cm">// ‚îÄ‚îÄ‚îÄ Time-based animation (frame-rate independent) ‚îÄ‚îÄ‚îÄ</span>
<span class="kw">let</span> start;
<span class="kw">const</span> duration = <span class="num">1000</span>; <span class="cm">// 1 second animation</span>

<span class="kw">function</span> <span class="fn">animateSmooth</span>(timestamp) {
  <span class="kw">if</span> (!start) start = timestamp;
  <span class="kw">const</span> elapsed  = timestamp - start;
  <span class="kw">const</span> progress = Math.<span class="fn">min</span>(elapsed / duration, <span class="num">1</span>); <span class="cm">// 0 to 1</span>

  <span class="cm">// Easing function (ease-out cubic)</span>
  <span class="kw">const</span> eased = <span class="num">1</span> - (<span class="num">1</span> - progress) ** <span class="num">3</span>;

  element.style.opacity = eased;
  element.style.transform = <span class="str">`translateY(${(<span class="num">1</span> - eased) * <span class="num">50</span>}px)`</span>;

  <span class="kw">if</span> (progress &lt; <span class="num">1</span>) requestAnimationFrame(<span class="fn">animateSmooth</span>);
}
requestAnimationFrame(<span class="fn">animateSmooth</span>);</pre>
    </div>
  </div>

  <div class="qa">
    <div class="qa-q" onclick="tog(this)"><span class="qa-n">Q.04</span><span class="qa-text">What causes memory leaks in JavaScript? How do you detect and fix them?</span><span class="qa-tog">+</span></div>
    <div class="qa-a">
      <p>A <strong>memory leak</strong> occurs when memory that's no longer needed is not released ‚Äî the garbage collector can't free it because there are still references pointing to it. In JavaScript, the garbage collector uses a "mark and sweep" algorithm: anything reachable from the roots (global objects, call stack) is kept; everything else is freed.</p>
      <h4>Common memory leak sources:</h4>
      <pre><span class="cm">// 1. Event listeners not removed</span>
<span class="kw">function</span> <span class="fn">createComponent</span>() {
  <span class="kw">const</span> data = <span class="kw">new</span> Array(<span class="num">100000</span>).<span class="fn">fill</span>(<span class="str">'memory'</span>);
  window.<span class="fn">addEventListener</span>(<span class="str">'resize'</span>, () => {
    console.<span class="fn">log</span>(data); <span class="cm">// closure keeps 'data' alive!</span>
  });
  <span class="cm">// Even after component is "destroyed", the listener (and data) live on</span>
}
<span class="cm">// Fix: remove listeners when component is destroyed</span>
<span class="kw">const</span> <span class="fn">handler</span> = () => console.<span class="fn">log</span>(data);
window.<span class="fn">addEventListener</span>(<span class="str">'resize'</span>, <span class="fn">handler</span>);
window.<span class="fn">removeEventListener</span>(<span class="str">'resize'</span>, <span class="fn">handler</span>); <span class="cm">// cleanup!</span>

<span class="cm">// 2. Timers not cleared</span>
<span class="kw">const</span> id = setInterval(() => {
  <span class="cm">// interval holds reference to callback and its closure</span>
  <span class="fn">doExpensiveWork</span>();
}, <span class="num">1000</span>);
clearInterval(id); <span class="cm">// Must clear when no longer needed!</span>

<span class="cm">// 3. Detached DOM nodes</span>
<span class="kw">const</span> elements = [];
<span class="kw">function</span> <span class="fn">addElement</span>() {
  <span class="kw">const</span> el = document.<span class="fn">createElement</span>(<span class="str">'div'</span>);
  document.body.<span class="fn">appendChild</span>(el);
  elements.<span class="fn">push</span>(el); <span class="cm">// still referenced!</span>
}
<span class="kw">function</span> <span class="fn">removeElement</span>() {
  <span class="kw">const</span> el = elements.<span class="fn">pop</span>();
  el.<span class="fn">remove</span>(); <span class="cm">// removed from DOM...</span>
  <span class="cm">// But el is gone from elements array now ‚Äî OK</span>
  <span class="cm">// If we kept it in elements array, it would be a detached DOM node leak</span>
}

<span class="cm">// 4. WeakMap/WeakSet ‚Äî use these to avoid leaks</span>
<span class="cm">// Keys held weakly ‚Äî if the object is garbage collected, entry auto-removed</span>
<span class="kw">const</span> cache = <span class="kw">new</span> WeakMap();
<span class="kw">function</span> <span class="fn">processElement</span>(el) {
  <span class="kw">if</span> (!cache.<span class="fn">has</span>(el)) {
    cache.<span class="fn">set</span>(el, <span class="fn">computeExpensiveResult</span>(el));
  }
  <span class="kw">return</span> cache.<span class="fn">get</span>(el);
  <span class="cm">// When 'el' is removed from DOM and has no other refs,</span>
  <span class="cm">// WeakMap automatically removes its entry</span>
}</pre>
    </div>
  </div>

  <div class="bottom-nav">
    <button class="btn" onclick="go('s10')">‚Üê Browser & Events</button>
    <button class="btn primary" onclick="go('s12')">Cheat Sheet ‚Üí</button>
  </div>
</div>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê S12: CHEAT SHEET ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div class="section" id="sec-s12">
  <div class="section-head">
    <div class="sec-num">‚òÖ</div>
    <div><div class="sec-title">Interview Day Cheat Sheet</div><div class="sec-sub">Quick-reference for every critical concept ‚Äî review before your interview</div></div>
  </div>

  <div class="cheat-grid">
    <div class="cheat-card">
      <div class="cheat-title">Execution Context</div>
      <div class="ci"><span class="ci-k">GEC phases</span><span class="ci-v">Memory creation ‚Üí Execution</span></div>
      <div class="ci"><span class="ci-k">FEC created when</span><span class="ci-v">Function invoked (not defined)</span></div>
      <div class="ci"><span class="ci-k">Call stack</span><span class="ci-v">LIFO ‚Äî last in, first out</span></div>
      <div class="ci"><span class="ci-k">Stack overflow</span><span class="ci-v">Infinite recursion, no base case</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">var vs let vs const</div>
      <div class="ci"><span class="ci-k">var scope</span><span class="ci-v">Function (not block)</span></div>
      <div class="ci"><span class="ci-k">let / const scope</span><span class="ci-v">Block {}</span></div>
      <div class="ci"><span class="ci-k">var hoisted as</span><span class="ci-v">undefined</span></div>
      <div class="ci"><span class="ci-k">let/const hoisted as</span><span class="ci-v">TDZ (uninitialized)</span></div>
      <div class="ci"><span class="ci-k">const</span><span class="ci-v">Binds variable, not value</span></div>
      <div class="ci"><span class="ci-k">Best practice</span><span class="ci-v">Always const ‚Üí let, never var</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">this ‚Äî 4 Rules (priority order)</div>
      <div class="ci"><span class="ci-k">1. new Fn()</span><span class="ci-v">New object instance</span></div>
      <div class="ci"><span class="ci-k">2. fn.call(ctx)</span><span class="ci-v">Explicitly provided ctx</span></div>
      <div class="ci"><span class="ci-k">3. obj.method()</span><span class="ci-v">obj (left of the dot)</span></div>
      <div class="ci"><span class="ci-k">4. fn()</span><span class="ci-v">window (non-strict) / undefined (strict)</span></div>
      <div class="ci"><span class="ci-k">Arrow functions</span><span class="ci-v">Lexical this (inherit from parent)</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Closures</div>
      <div class="ci"><span class="ci-k">Definition</span><span class="ci-v">Fn retains access to outer scope after it returns</span></div>
      <div class="ci"><span class="ci-k">Captures</span><span class="ci-v">Reference (not copy)</span></div>
      <div class="ci"><span class="ci-k">var loop bug</span><span class="ci-v">All callbacks share 1 var</span></div>
      <div class="ci"><span class="ci-k">Fix 1</span><span class="ci-v">Use let (new binding per iteration)</span></div>
      <div class="ci"><span class="ci-k">Fix 2</span><span class="ci-v">IIFE wraps each iteration</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Event Loop</div>
      <div class="ci"><span class="ci-k">Call stack</span><span class="ci-v">Synchronous code</span></div>
      <div class="ci"><span class="ci-k">Web APIs</span><span class="ci-v">setTimeout, fetch, DOM events</span></div>
      <div class="ci"><span class="ci-k">Microtask queue</span><span class="ci-v">Promise callbacks (higher priority)</span></div>
      <div class="ci"><span class="ci-k">Macrotask queue</span><span class="ci-v">setTimeout, setInterval</span></div>
      <div class="ci"><span class="ci-k">Order</span><span class="ci-v">Sync ‚Üí microtasks ‚Üí macrotask ‚Üí repeat</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Promise States</div>
      <div class="ci"><span class="ci-k">pending</span><span class="ci-v">Initial, neither settled state</span></div>
      <div class="ci"><span class="ci-k">fulfilled</span><span class="ci-v">Resolved with value ‚Üí .then()</span></div>
      <div class="ci"><span class="ci-k">rejected</span><span class="ci-v">Failed with reason ‚Üí .catch()</span></div>
      <div class="ci"><span class="ci-k">settled</span><span class="ci-v">Fulfilled OR rejected (final)</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Promise Combinators</div>
      <div class="ci"><span class="ci-k">Promise.all()</span><span class="ci-v">All succeed or fast-fail</span></div>
      <div class="ci"><span class="ci-k">Promise.allSettled()</span><span class="ci-v">All settle (never rejects)</span></div>
      <div class="ci"><span class="ci-k">Promise.race()</span><span class="ci-v">First to settle wins</span></div>
      <div class="ci"><span class="ci-k">Promise.any()</span><span class="ci-v">First to RESOLVE wins</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Copying Objects</div>
      <div class="ci"><span class="ci-k">Shallow copy</span><span class="ci-v">{ ...obj } or Object.assign()</span></div>
      <div class="ci"><span class="ci-k">Deep copy (modern)</span><span class="ci-v">structuredClone(obj)</span></div>
      <div class="ci"><span class="ci-k">Deep copy (limited)</span><span class="ci-v">JSON.parse(JSON.stringify())</span></div>
      <div class="ci"><span class="ci-k">Shared nested</span><span class="ci-v">Shallow copy shares nested refs!</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">typeof Quirks</div>
      <div class="ci"><span class="ci-k">typeof null</span><span class="ci-v">'object' ‚Üê historic bug</span></div>
      <div class="ci"><span class="ci-k">typeof []</span><span class="ci-v">'object' (not 'array'!)</span></div>
      <div class="ci"><span class="ci-k">typeof NaN</span><span class="ci-v">'number' (not 'nan'!)</span></div>
      <div class="ci"><span class="ci-k">Check null</span><span class="ci-v">val === null</span></div>
      <div class="ci"><span class="ci-k">Check array</span><span class="ci-v">Array.isArray(val)</span></div>
      <div class="ci"><span class="ci-k">Check NaN</span><span class="ci-v">Number.isNaN(val)</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Debounce vs Throttle</div>
      <div class="ci"><span class="ci-k">Debounce fires</span><span class="ci-v">After quiet period</span></div>
      <div class="ci"><span class="ci-k">Throttle fires</span><span class="ci-v">At most once/interval</span></div>
      <div class="ci"><span class="ci-k">Debounce use</span><span class="ci-v">Search input, auto-save</span></div>
      <div class="ci"><span class="ci-k">Throttle use</span><span class="ci-v">Scroll, mouse move, resize</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Array Methods (Immutable)</div>
      <div class="ci"><span class="ci-k">map(fn)</span><span class="ci-v">Transform each ‚Üí new array</span></div>
      <div class="ci"><span class="ci-k">filter(fn)</span><span class="ci-v">Keep matching ‚Üí new array</span></div>
      <div class="ci"><span class="ci-k">reduce(fn, init)</span><span class="ci-v">Accumulate ‚Üí single value</span></div>
      <div class="ci"><span class="ci-k">Always provide</span><span class="ci-v">initialValue to reduce</span></div>
    </div>

    <div class="cheat-card">
      <div class="cheat-title">Event Propagation</div>
      <div class="ci"><span class="ci-k">Capture phase</span><span class="ci-v">Window ‚Üí target (down)</span></div>
      <div class="ci"><span class="ci-k">Bubble phase</span><span class="ci-v">Target ‚Üí window (up)</span></div>
      <div class="ci"><span class="ci-k">stopPropagation</span><span class="ci-v">Stops DOM travel</span></div>
      <div class="ci"><span class="ci-k">preventDefault</span><span class="ci-v">Stops browser default action</span></div>
      <div class="ci"><span class="ci-k">Delegation</span><span class="ci-v">One parent listener handles all children</span></div>
    </div>
  </div>

  <div class="callout tip" style="margin-top:28px">
    <div class="callout-title">üéØ Top Interview Tips</div>
    <ul>
      <li>Always <strong>think out loud</strong> ‚Äî interviewers want to see your reasoning, not just the answer</li>
      <li>Mention <strong>edge cases</strong> proactively: null, undefined, empty arrays, nested structures</li>
      <li><strong>Connect concepts</strong>: closures ‚Üí lexical scope ‚Üí var loop bug is a beautiful chain</li>
      <li>Draw the <strong>event loop diagram</strong> when asked about async execution order</li>
      <li>Relate JavaScript concepts to <strong>React implications</strong> (mutation breaking state detection)</li>
      <li>Explain <strong>why</strong>, not just what ‚Äî "I use const by default because it signals immutable binding"</li>
      <li>Mention <strong>tradeoffs</strong>: structuredClone vs JSON method, debounce vs throttle</li>
    </ul>
  </div>

  <div class="bottom-nav">
    <button class="btn" onclick="go('s11')">‚Üê Advanced Concepts</button>
    <button class="btn" onclick="go('overview')">Back to Overview</button>
  </div>
</div>

</div><!-- /content -->
</main>
</div><!-- /app -->

<script>
const sections = ['overview','s1','s2','s3','s4','s5','s6','s7','s8','s9','s10','s11','s12'];
const visited = new Set(JSON.parse(localStorage.getItem('courseVisited') || '["overview"]'));

function saveProgress() {
  localStorage.setItem('courseVisited', JSON.stringify(Array.from(visited)));
  const pct = Math.round((visited.size / sections.length) * 100);
  localStorage.setItem('courseProgress', pct);
}

function go(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
  const sec = document.getElementById('sec-' + id);
  if (sec) { sec.classList.add('active'); sec.scrollIntoView({ behavior: 'smooth', block: 'start' }); }
  const nav = document.querySelector('[data-s="' + id + '"]');
  if (nav) { nav.classList.add('active'); }
  visited.add(id);
  document.querySelectorAll('.nav-item').forEach(n => {
    if (visited.has(n.dataset.s) && !n.classList.contains('active')) n.classList.add('visited');
  });
  const pct = Math.round((visited.size / sections.length) * 100);
  document.getElementById('pct').textContent = pct + '%';
  document.getElementById('fill').style.width = pct + '%';
  saveProgress();
}

function tog(el) {
  const qa = el.closest('.qa');
  qa.classList.toggle('open');
}

// init
document.querySelector('[data-s="overview"]').classList.add('active');
const pct = Math.round((visited.size / sections.length) * 100);
document.getElementById('pct').textContent = pct + '%';
document.getElementById('fill').style.width = pct + '%';
document.querySelectorAll('.nav-item').forEach(n => {
  if (visited.has(n.dataset.s) && n.dataset.s !== 'overview') n.classList.add('visited');
});
</script>
</body>
</html>
